#! /bin/sh
# vim: set tabstop=4 shiftwidth=4 syntax=sh highlight=on
# SPDX-License-Identifier: GPL-2.0-or-later
################################################################################
#                                                                              #
# an alternative approach to modify firmware images for AVM FRITZ!Box routers  #
#                                                                              #
# Copyright (C) 2014-2020 P.HÃ¤mmerlein (http://www.yourfritz.de)               #
#                                                                              #
# This program is free software; you can redistribute it and/or                #
# modify it under the terms of the GNU General Public License                  #
# as published by the Free Software Foundation; either version 2               #
# of the License, or (at your option) any later version.                       #
#                                                                              #
# This program is distributed in the hope that it will be useful,              #
# but WITHOUT ANY WARRANTY; without even the implied warranty of               #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                #
# GNU General Public License under                                             #
# http://www.gnu.org/licenses/gpl-2.0.html                                     #
# for more details.                                                            #
#                                                                              #
# "FRITZ!Box" and "FRITZ!" are registered word marks and "AVM" is a registered #
# word and figurative mark of:                                                 #
# AVM Computersysteme Vertriebs GmbH, 10559, Berlin, DE.                       #
#                                                                              #
################################################################################
#
# AVM "constants"
#
# procfs of MTD driver
procmtd="/proc/mtd"
# device name of MTD partition for access with character oriented I/O
mtdprefix="mtd"
# device name of MTD partitions for access with block oriented I/O
mtdblockname="mtdblock"
# prefix for inactive partition names
reservedprefix="reserved-"
# name of kernel partition
kernelname="kernel"
# name of file system partition
filesystemname="filesystem"
# name of the partition with NAND flash available to the user
nandname="nand-filesystem"
# environment file name within the TFFS procfs
envpathname="/proc/sys/urlader/environment"
# variable used to switch between boot time systems
fsvarname="linux_fs_start"
# hardware revision variable name
hwrevname="HWRevision"
# supported hardware revisions as "modfs" host
# 3370, 7490, 3390, 7362SL, 3490, 7430, 7412, 7272, 3272, 5490, 5491
hwrevs_supported="175 185 193 203 212 209 218 192 198 223 243"
# AVM's binary to modify the NAND based partitions (busybox has it's own tools, but not ooB on a device with original firmware)
update_kernel_binary="/sbin/update_kernel"
# where is the wrapper mounted at the running system ? (if any)
wrapperdir="/wrapper"
# the file name of the root file system image, if a wrapper YAFFS2 image exists
rootfsname="filesystem_core.squashfs"
# the name of a firmware image, it will be renamed during download
firmwarestoragename="firmware.image"
# the kernel image name within a firmware image
firmware_kernel_image="./var/tmp/kernel.image"
# the (outer) file system image name within a firmware image
firmware_filesystem_image="./var/tmp/filesystem.image"
# (outer) file system image file name
outerimagename="filesystem.image"
# kernel image file name
kernelfilename="kernel.image"
# the name of the busybox to be used, will be changed later
bb="/bin/busybox"
# the name of the shell on the box
shl="$bb sh"
# the name of vendor utility to "spy" into files
testvalue="/bin/testvalue"
# the name of the ring buffer utility from the vendor
debugoutput="/bin/showshringbuf -i \$scriptname"
## the name of the ring buffer utility from the vendor
debugtest="/bin/showshringbuf -?"
# our debug ring buffer file name
ringbufferfile="/var/.srb_\$scriptname"
# our custom modscript selection file name
custom_selection_file="custom_modscripts"
#
# some more values which have to be changed, if AVM modifies its firmware
#
# 128MB ext3 image plus 10 percent
free_space_for_unpack="285M"
# 48 MB for packed and double space for unpacked image
free_space_for_unpack_tmpfs="512M"
# even with a small amount of RAM at all, there should be a minimum of free space
free_space_at_tmpfs="128M"
# that's really low on space, better restart the box again
warning_space_at_tmpfs="64M"
# one more time the space needed for our ext3 container + 5%
free_space_at_nand="285M"
# the estimated space needed to store an extracted squashfs image at NAND, it's hard
# to predict a correct value, because the available 48 MB of a filesystem partition
# may contain a much much larger "expanded" structure due to automatic avoidance of
# compression for identical files - so we use a value usually large enough to contain
# up to four different brandings
warning_space_at_nand="192M"
# the estimated space needed to download a firmware image from the FTP server,
# computed as filesystem partition size + kernel partition size + security surcharge
# for additional files in the tar archive - currently the images are uncompressed
download_space_needed="128M"
# the estimated space needed to extract an outer file system from a firmware image,
# the extracted tree may be be larger than the size of a filesystem partition
extract_space_needed="48M"
# the estimated space needed to store a kernel image, an outer image (if used) and the
# extracted SquashFS image - at least during the modify_rootfs execution,
# computed as kernel partition size + 2x filesystem partition size, because it's
# possible, that (in worst case) the (outer) ext2 image with the pseudo SquashFS header
# exists together with the "cutted" image (during "dd" execution) for a short time,
# the extracted SquashFS image will be smaller than the second ext2 copy
fullimage_space_needed="256M"
# needed swap space at all (MB)
swap_space_needed="512"
# the "normal" base for temporary files and directories
tmpfsbasedir="/var/tmp"
# known native file system types, we can use them without a container
nativefilesystems="tmpfs ext2 ext3 ext4 yaffs2"
#
# error codes
#
#  32 - different MD5 hashes for kernel MTDs
#  33 - unable to find kernel MTD
#  34 - unable to find alternative kernel MTD
#  35 - not used anymore, was missing linux_fs_start at environment
#  36 - unsupported hardware revision
#  37 - system modified already, restart needed
#  38 - specified squashfs source file not found
#  39 - unable to extract outer image from firmware archive
#  40 - unable to mount outer file system
#  41 - unable to copy root image from outer filesystem
#  42 - unable to download firmware image from manufacturer
#  43 - error downloading firmware image (file size is 0)
#  44 - error copying kernel image to alternative partition
#  45 - error copying outer file system to alternative partition
#  46 - unknown error copying running system to inactive partitions
#  47 - unable to get hardware revision
#  48 - unable to find file system MTD partition
#  49 - unable to find alternative file system MTD partition
#  50 - not enough free space available at tmpfs
#  51 - unable to find free space for unpacking of squashfs
#  52 - unable to find free space for squashfs extraction from image
#  53 - error saving permanent copy of source squashfs image
#  54 - error unpacking loopback device image
#  55 - error mounting loopback device image
#  56 - error unmounting loopback device image
#  57 - error removing loopback device image
#  58 - not enough free space on any storage volume
#  60 - wrong modscript detected, missing needed comment lines
#  61 - wrong modscript detected, missing header at all
#  62 - error extracting kernel image from firmware image file
#  66 - the message file was not found after fallback to 'en'
# 127 - internal error
# 187 - unable to detect the current firmware version on the FTP server
# 190 - no newer version found for "update" mode without local source file
# 191 - error comparing version numbers (e.g. wrong format of them)
# 200 - input image is missing or invalid
# 202 - unspecified error mounting an ext2 image to extract data from it
# 205 - a downloaded image file did not pass the integrity check (signature)
# 222 - error detecting filesystem type of an image file
#
# our "internal" constants
#
modfs_version=0.8.1-050520221627
modfs_comment="please look at https://github.com/PeterPawn/modfs for further info"
bindirname="bin"
localedirname="locale"
filesdirname="files"
scriptdirname="modscripts"
contribdirname="contrib"
tmpdirbase="/var/tmp"
packedpartition="256MB_ext3.gz"
squashfsdirname="squashfs-root"
scriptwrapper="wrap_script"
modfsshelldebug="/var/tmp/modfs_debug_shell.log"
scriptsdir="bin/scripts"
getversionvaluesscript="$scriptsdir/extract_version_values"
showprogress=0
msgtext_clearscreen="\x1B[2J\x1B[0;0H"
msgtext_normal="\x1B[0m"
msgtext_bold="\x1B[1m"
msgtext_error="\x1B[1;31m"
msgtext_ok="\x1B[1;32m"
msgtext_warning="\x1B[1;33m"
msgtext_highlight="\x1B[1;34m"
msgtext_CR="\r\x1B[K"
#
# name and relative path of squashfs tools
#
sq_version=4 # default version
sq_pack="\$(bindir)/mksquashfs\${sq_version}"
sq_unpack="\$(bindir)/unsquashfs\${sq_version}"
#
# universal functions
#
# check, if a list contains an item and return its index (based on 1)
# $1 - the item to look for (needle)
# $2 - the haystack
#
index_of_item()
{
	local item i=0
	for item in $2; do
		let i+=1
		[ x"$1" == x"$item" ] && echo $i && return 0
	done
	return 1
}
#
# get binaries subdirectory name
#
bindir() { echo "$scriptpath/$bindirname/$(get_hardware_revision)"; }
#
# get scripts subdirectory name
#
scriptdir() { echo "$scriptpath/$scriptsdir"; }
#
# get locale subdirectory name
#
localedir() { echo "$scriptpath/$localedirname"; }
#
# get files subdirectory name
#
filesdir() { echo "$scriptpath/$filesdirname"; }
#
# get contributed content subdirectory name
#
contribdir() { echo "$scriptpath/$contribdirname"; }
#
# remove temporary file
# $1 - file name
#
remove_temp_file()
{
	local rc
	[ -z "$1" ] && return 127
	[ ${#1} -lt 10 ] && return 127
	$bb rm "$1" 2>/dev/null
	rc=$?
	$bb sed -e "\|^rm *$1\$|d" -i $tempfilelist 2>/dev/null
	debug "remove_temp_file: file=$1, rc=$rc"
	return 0
}
#
# remove directory and its reference from cleanup list too
# $1 - directory to remove
#
remove_directory()
{
	local dir="$1" rc
	[ ${#1} -lt 10 ] && return 127
	$bb rm -r $dir 2>/dev/null
	rc=$?
	$bb sed -e "\|^rm -r *$dir\$|d" -i $tempfilelist 2>/dev/null
	debug "remove_directory: directory=$1, rc=$rc"
	return 0
}
#
# get temporary directory name
#
get_temp_dir()
{
	local name="$tmpdirbase/$$_$($bb date +%s)"
	$bb mkdir -p "$name"
	echo "$bb rm -r $name" >>$tempfilelist
	debug "get_temp_dir: directory=$name"
	echo "$name"
	return 0
}
#
# get temporary file name
# $1 - optional base directory name
#
get_temp_file()
{
	local name="$1" dir out
	dir="$(get_temp_dir)"
	[ -z "$name" ] && out="$dir/$($bb date +%s)" || out="$dir/$name"
	echo "$bb rm $out" >>$tempfilelist
	debug "get_temp_file: file=$out"
	echo "$out"
	return 0
}
#
# write to debug ring buffer
# stdin -> lines to append to the buffer
#
debug()
{
	[ $MODFS_DEBUG -ne 1 ] && return
	echo -e "$@" | $bb sed -e ':x;$!N;s/\n/{LF}/;tx' | $debugoutput
}
#
# get next system index from environment
#
get_system_switch()
{
	local fsvar
	fsvar=$($bb sed -n -e "s/^$fsvarname\t\([01]\)/\1/p" $envpathname)
	[ -z "$fsvar" ] && fsvar="0"
	echo $fsvar
}
#
# get hardware revision from environment (it has not to be a number !)
#
get_hardware_revision() { $bb sed -n -e "s/^$hwrevname\t\(.*\)/\1/p" $envpathname; }
#
# check, if the specified hardware revision is supported
# $1 - hardware revision
#
check_hardware_revision() { return $(index_of_item "$1" "$hwrevs_supported"); }
#
# check MTD "name"
# $1 - MTD index number
# $2 - expected MTD name from /proc/mtd
#
check_mtd() { $bb grep "$mtdprefix$1: [0-9a-f]* [0-9a-f]* \"\($reservedprefix\)*$2\"" $procmtd; }
#
# get MTD number by name
# $1 - requested MTD partition name
#
get_mtd_by_name() { $bb sed -n -e "s|$mtdprefix\([0-9]\{1,2\}\): [0-9a-f]\{8\} [0-9a-f]\{8\} \"$1\"|\1|p" $procmtd; }
#
# get MTD name by number
# $1 - requested MTD partition number
#
get_mtd_by_number() { $bb sed -n -e "s|$mtdprefix$1: [0-9a-f]\{8\} [0-9a-f]\{8\} \"\(.*\)\"|\1|p" $procmtd; }
#
# build MTD partition groups
#
build_partitions()
{
	local g1 g2
	g1=$(get_mtd_by_name $kernelname):$(get_mtd_by_name $filesystemname)
	g2=$(get_mtd_by_name $reservedprefix$kernelname):$(get_mtd_by_name $reservedprefix$filesystemname)
	if [ ${g1:0:1} -lt ${g2:0:1} ]; then
		echo "$g1 $g2"
	else
		echo "$g2 $g1"
	fi
}
#
# convert string to upper case
# $@ - string(s) to convert
#
uppercase() { echo "$@" | $bb tr 'abcdefghijklmnopqrstuvwxyzÃ¤Ã¶Ã¼' 'ABCDEFGHIJKLMNOPQRSTUVWXYZÃÃÃ'; }
#
# escape a string to use it within a regular expression without any hassle
#
escape_regexp() { echo "$@" | $bb sed -e 's/\./\\./g'; }
#
# get localized strings (to make it easier for german users)
# - the message text may contain the macros '%{error}', '%{ok}', '%{warning}' and
#   '%{normal}' to change text color
# - to insert variable parts into the text, the 'printf' command will be used with
#   the specified parameters (shifted two times to remove our own arguments)
# $1 - language index (ISO 639-1 code)
# $2 - message id
# $3-$n - values to substitute
#
get_localized()
{
	local lang=$1 lcfile=$(localedir)/$lang msgno=$2 rc=0 msg
	shift 2
	msg="$($bb sed -n -e "/^$msgno=/s/^[0-9]*=\(.*\)/\1/p" $lcfile | $bb sed -e "s/%{error}/\${msgtext_error}/g" | $bb sed -e "s/%{ok}/\${msgtext_ok}/g" | $bb sed -e "s/%{warning}/\${msgtext_warning}/g" | $bb sed -e "s/%{bold}/\${msgtext_bold}/g" | $bb sed -e "s/%{normal}/\${msgtext_normal}/g" | $bb sed -e "s/%{highlight}/\${msgtext_highlight}/g")"
	if [ "${#msg}" = "0" ]; then
		echo "The specified message number $msgno was not found at the language file for '$lang'." 1>&2
		rc=1
	else
        eval "printf \"$msg\" "$@""
	fi
	return $rc
}
#
# get a yes or no decision from the user
# $1 - default answer to assume, if only return is pressed
# $2 - the question to display first
# - to avoid a default answer (return key), use any other default than 'y' or 'n'
#
ask_yes_or_no()
{
	local def=$1 yes no p_yes p_no answer nl prompt="$2"
	yes=$(get_localized $lang 129)
	no=$(get_localized $lang 130)
	cancel=$(get_localized $lang 227)
	p_yes=$yes
	p_no=$no
	p_cancel="$(get_localized $lang 228)"
	if [ $def == n ]; then
		p_no=$(uppercase $no)
	else
		if [ $def == y ]; then
			p_yes=$(uppercase $yes)
		fi
	fi
	# 1 -eq 1 is better than 'true', because 'true' is not an ash builtin in every case
	debug "ask_yes_or_no: Q=$prompt"
	while [ 1 -eq 1 ]; do
		while read -n 10 -s -t 1; do :; done
		echo -ne "$prompt" 1>&2
		read -n 1 -s -p " ($p_yes/$p_no/$p_cancel) " answer 1>&2
		nl="$answer\n"
		[ ${#answer} -eq 0 ] && answer=$def && nl="\n"
		debug "ask_yes_or_no: A=$answer"
		if [ "$answer" == $(uppercase $yes) -o $answer == $yes ]; then
			echo -n 'Y'
			echo -e -n "$nl" 1>&2
			return 0
		elif [ "$answer" == $(uppercase $no) -o $answer == $no ]; then
			echo -n  'N'
			echo -e -n "$nl" 1>&2
			return 0
		elif [ "$answer" == $(uppercase $cancel) -o $answer == $cancel ]; then
			echo -n  'C'
			echo -e -n "$nl" 1>&2
			return 1
		else
			echo -e "$selection\n$(get_localized $lang 128)" 1>&2
		fi
	done
	return 1
}
#
# show progress messages on console
# - output will be written to stderr
# $1 - message type
#      1 - CR + show text without LF
#      2 - show text without LF
#      3 - show text with LF
#      4 - show text with LF in front of it and at the end
# $2 - message id to get localized text version
#
progress()
{
	local msg mode=$1
	shift
	msg="$(get_localized $lang "$@")"
	if [ $mode -eq 1 ]; then
		echo -ne "$msgtext_CR$msg" 1>&2
	else
		if [ $mode -eq 2 ]; then
			echo -ne "$msg" 1>&2
		else
			if [ $mode -eq 3 ]; then
				echo -ne "$msg\n" 1>&2
			else
				if [ $mode -eq 4 ]; then
					echo -ne "\n$msg\n"
				fi
			fi
		fi
	fi
	debug "progress: mode=$mode, msg=$msg"
	return
}
#
# check next system against running
#
is_switched()
{
	local nxt kernel filesys kname fname switched=1
	nxt=$(get_system_switch)
	set -- $(build_partitions)
	[ $nxt -gt 0 ] && shift
	kernel=${1%:*}
	filesys=${1#*:}
	kname="$(get_mtd_by_number $kernel)"
	fname="$(get_mtd_by_number $filesys)"
	[ "${kname:0:${#reservedprefix}}" == "$reservedprefix" ] && switched=0
	return $switched
}
#
# compare kernel checksums to make sure, the systems are identical
# $1 and $2 have to be the MTD numbers of the two kernel images
#
check_kernels()
{
	local rc=0
	if [ ${#1} -eq 0 -o ${#2} -eq 0 ];then
		rc=127
	else
		hash0=$($bb md5sum /dev/$mtdblockname$1 | $bb sed -n -e 's/^\([0-9a-f]*\).*/\1/p')
		hash1=$($bb md5sum /dev/$mtdblockname$2 | $bb sed -n -e 's/^\([0-9a-f]*\).*/\1/p')
		debug "check_kernels: /dev/$mtdblockname$1 = $hash0, /dev/$mtdblockname$2 = $hash1"
		if [ $hash0 != $hash1 ]; then
			rc=32
		fi
	fi
	return $rc
}
#
# call mksquashfs utility
#
sq_mksquashfs()
{
	local rc=0 binary
	binary="$(eval echo $sq_pack)"
	debug "sq_mksquashfs: $binary $@"
	$binary "$@"
	rc=$?
	debug "sq_mksquashfs: exiting, rc=$rc"
	return $rc
}
#
# call unsquashfs utility
#
sq_unsquashfs()
{
	local rc=0 binary
	binary="$(eval echo $sq_unpack)"
	debug "sq_unsquashfs: $binary $@"
	$binary "$@"
	rc=$?
	debug "sq_unsquashfs: exiting, rc=$rc"
	return $rc
}
#
# switch system selection variable to other value
#
switch_system()
{
	local newval
	newval=$(( ( $(get_system_switch) + 1 ) % 2 ))
	echo $fsvarname $newval >$envpathname
	debug "switch_system: switched to $newval"
}
#
# switch next boot time selection to specified system, if action is really needed
# $1 - 'running' / 'alternative' to switch to the specified system based on the running version
#
switch_system_to()
{
	local next
	next=$(get_system_switch)
	debug "switch_system_to: $1"
	if is_switched; then
		if [ x"$1" == xcurrent ]; then
			switch_system
		fi
	else
		if [ x"$1" == xalternative ]; then
			switch_system
		fi
	fi
	return 0
}
#
# detect filesystem image type
# types supported: squashfs3, squashfs4, ext2, sqfs_dummy256_{type}, with "-de" suffix if different endianess detected
# $1 - source image
#
detect_image_filesystem()
{
	local src="$1" rc=222 fstype major sig offset=${2:-0}
	# do not use blkid anymore to avoid confusions from different versions
	# instead we'll probe at different offsets to detect/guess the right type
	[ -f "$src" ] || return $rc
	sig=$($testvalue "$src" 4 $offset)
	[ $? -ne 0 ] && return $rc
	major=$($testvalue "$src" 2 $(( offset + 28 )))
	[ $? -ne 0 ] && return $rc
	if [ $sig == 1936814952 ]; then
		# sqsh signature found at offset 0
		if [ $major -ne 0 ]; then
			fstype="squashfs$major"
		else
			if [ $offset -eq 0 ]; then
				# recursive call with offset 256
				sig="$(detect_image_filesystem "$src" 256)"
				if [ $? -eq 0 ]; then
					fstype="sqfs_dummy256_$sig"
				fi
			fi
		fi
	elif [ $sig == 1752396147 ]; then
		# different endian signature found at offset 0
		if [ $major -ne 0 ]; then
			fstype="squashfs${major}-de"
		fi
	else
		sig=$($testvalue "$src" 2 $(( offset + 1080 )))
		if [ $sig -eq 21487 ]; then
			fstype="ext2"
		fi
	fi
	[ ${#fstype} -gt 0 ] && rc=0
	echo $fstype
	debug "detect_image_filesystem: src=$src, offset=$offset, fstype=$fstype, rc=$rc"
	return $rc
}
#
# copy kernel image to alternative partition
# $1 - optional file name of the new kernel image - if omitted, the current kernel will be copied
#
copy_kernel_image()
{
	local src="$1" target rc
	if [ ${#src} -eq 0 ]; then
		src=$(get_mtd_by_name $kernelname)
		src="/dev/$mtdprefix$src"
	fi
	target=$(get_mtd_by_name $reservedprefix$kernelname)
	debug "copy_kernel_image: src=$src, target=/dev/$mtdprefix$target"
	$update_kernel_binary -i "$src" -o /dev/$mtdprefix$target >/dev/null 2>&1
	rc=$?
	debug "copy_kernel_image: exiting, rc=$rc"
	return $rc
}
#
# copy outer file system to alternative partition
#
copy_filesystem()
{
	local tmp target rc
	target=$(get_mtd_by_name $reservedprefix$filesystemname)
	$update_kernel_binary -o /dev/$mtdprefix$target >/dev/null 2>&1
	debug "copy_filesystem: /dev/$mtdprefix$target cleared"
	tmp=$(get_temp_dir)
	$bb mount -t yaffs2 /dev/$mtdblockname$target "$tmp"
	$bb cp -R $wrapperdir/* $tmp/
	rc=$?
	debug "copy_filesystem: copied everything from $tmp, rc=$rc"
	$bb umount "$tmp"
	remove_directory "$tmp"
	debug "copy_filesystem: exiting, rc=$rc"
	return $rc
}
#
# copy running system to alternative partitions
#
copy_running_system()
{
	local rc
	# prepare MTD writes
	# notify power management
	echo MODE=update > /dev/avm_power
	# prevent unwanted watchdog restarts, may be necessary but update is very fast
	# echo "disable" > /dev/watchdog
	copy_kernel_image
	rc=$?
	if [ $rc -ne 0 ]; then
		rc=44
	else
		copy_filesystem
		rc=$?
		if [ $rc -ne 0 ]; then
			rc=45
		fi
	fi
	debug "copy_running_system: exiting, rc=$rc"
	return $rc
}
#
# copy new outer file system
# $1 - source file system image
# $2 - root file system image name to be excluded from copying
#
copy_outer_filesystem()
{
	local rc target src="$1" tmp fstype mrc=0 kernelversion
	target=$(get_mtd_by_name $reservedprefix$filesystemname)
	# prepare MTD writes
	# notify power management
	echo MODE=update > /dev/avm_power
	# prevent unwanted watchdog restarts, may be necessary but update is very fast
	# echo "disable" > /dev/watchdog
	# clear filesystem first
	debug "copy_outer_filesystem: src=$src, rootfs=$rootfsname"
	$update_kernel_binary -o /dev/$mtdprefix$target >/dev/null 2>&1
	rc=$?
	debug "copy_outer_filesystem: clearing target device /dev/$mtdprefix$target, rc=$rc"
	if [ $rc -ne 0 ]; then
		rc=44
	else
		fstype=$(detect_image_filesystem "$src")
		rc=$?
		if [ $rc -eq 0 ]; then
			# mount squashfs and yaffs2 partition and copy from one to the other
			tmp="$(get_temp_dir)"
			$bb mkdir -p "$tmp/yaffs" "$tmp/outerfs"
			$bb mount -t yaffs2 /dev/$mtdblockname$target "$tmp/yaffs"
			if [ "$fstype" == "ext2" -o "$fstype" == "sqfs_dummy256_ext2" ]; then
				# ext2 image with AVM's dummy header
				mount_ext2_image "$src" "$tmp/outerfs" "$fstype"
				rc=$?
				mrc=$rc
			else
				$bb mount "$src" "$tmp/outerfs" 2>/dev/null
				rc=$?
				mrc=$rc
				if [ $rc -ne 0 ]; then
					# try to extract with unsquashfs3, if this is a 3.xx kernel based
					# system without knowledge about SquashFS3 format while mounting
					kernelversion=$($bb uname -r)
					kernelversion=${kernelversion%%.*}
					if [ $kernelversion -eq 3 -a x"$fstype" == x"squashfs3" ]; then
						unpack_squashfs "$src" "$tmp" 2>&1 >/dev/null
						rc=$?
						if [ $rc -eq 0 ]; then
							$bb rmdir "$tmp/outerfs"
							$bb mv "$tmp/$squashfsdirname" "$tmp/outerfs"
							rc=$?
							$bb rm "$tmp/outerfs/$rootfsname"
						fi
					fi
				fi
			fi
			if [ $rc -eq 0 ]; then
				$bb tar -c -O -C "$tmp/outerfs" --exclude=$rootfsname . | $bb tar -x -C "$tmp/yaffs"
				rc=$?
				debug "copy_outer_filesystem: copying done, rc=$rc"
				if [ -n "$ADD_TO_WRAPPER" ]; then
					ADD_TO_WRAPPER="$(eval printf "%s" "$ADD_TO_WRAPPER")"
					if [ -d "$ADD_TO_WRAPPER" ]; then
						debug "copy_outer_filesystem: subdirectory '$ADD_TO_WRAPPER' exists, copying content to the new wrapper partition"
						cp -a $ADD_TO_WRAPPER/* $tmp/yaffs/
						rc=$?
						debug "copy_outer_filesystem: add_to_wrapper directory '$ADD_TO_WRAPPER' copied, rc=$rc"
					else
						debug "copy_outer_filesystem: add_to_wrapper directory '$ADD_TO_WRAPPER' not found"
					fi
				fi
				[ $mrc -eq 0 ] && $bb umount -d "$tmp/outerfs"
				$bb umount "$tmp/yaffs"
				remove_directory "$tmp"
				rc=0
			fi
		fi
	fi
	debug "copy_outer_filesystem: exiting, rc=$rc"
	return $rc
}
#
# copy new root file system to alternative YAFFS2 partition
# $1 - file name of new root file system image
#
copy_new_root_filesystem()
{
	local src="$1" target tmp
	target=$(get_mtd_by_name $reservedprefix$filesystemname)
	tmp="$(get_temp_dir)"
	debug "copy_new_root_filesystem: src=$src, target=/dev/$mtdblockname$target"
	$bb mount -t yaffs2 /dev/$mtdblockname$target "$tmp"
	$bb cp -a "$src" "$tmp/$rootfsname"
	rc=$?
	$bb umount "$tmp"
	remove_directory "$tmp"
	debug "copy_new_root_filesystem: exiting, rc=$rc"
	return $rc
}
#
# get squash file system block size
# $1 - source file system name
#
get_squashfs_blocksize()
{
	local bs sq_version
	sq_version=$(get_squashfs_tools_version "$1")
	debug "get_squashfs_blocksize: using SquashFS version $sq_version"
	bs=$(sq_unsquashfs -s "$1" 2>/dev/null | $bb sed -n -e "s/^Block size \(.*\)/\1/p")
	debug "get_squashfs_blocksize: block size=$bs"
	echo $bs
}
#
# get squash file system block size
# $1 - source file system name
#
get_squashfs_endianess()
{
	local endianess=0 endian sq_version
	sq_version=$(get_squashfs_tools_version "$1")
	debug "get_squashfs_endianess: using SquashFS version $sq_version"
	endian=$(sq_unsquashfs -s "$1" 2>/dev/null | $bb sed -n -e "s/Found a valid \(big\|little\) endian SQUASHFS.*/\1/p")
	[ ${#endian} -gt 0 ] && [ x"$endian" == xlittle ] && endianess=1
	debug "get_squashfs_endianess: $endian endian"
	echo $endianess
	return 0
}
#
# unpack squash file system
# $1 - source file system name
# $2 - target directory (has to exist)
# $3 - optional file with list of names to unpack
#
unpack_squashfs()
{
	local src="$1" target="$2" files="$3" popd rc sq_version
	if [ -r "$src" ]; then
		sq_version=$(get_squashfs_tools_version "$src")
		debug "unpack_squashfs: using SquashFS version $sq_version"
		[ -z "$files" ] || files="-e $files"
		popd="$(pwd)"
		cd "$target"
		sq_unsquashfs -info "$src" $files
		rc=$?
		cd "$popd"
	else
		rc=38
	fi
	debug "unpack_squashfs: exiting, rc=$rc"
	return $rc
}
#
# pack squash file system image from source tree
# $1 - source directory
# $2 - target file name
# $3 - endianess (0 - BE, 1 - LE)
# $4 - block size
#
pack_squashfs()
{
	local src="$1" target="$2" endian blocksize="$4" popd rc sq_version=$5
	if [ $sq_version -eq 3 ]; then
		[ $3 -eq 0 ] && endian="-be" || endian="-le"
	else
		endian=""
	fi
	popd="$(pwd)"
	debug "pack_squashfs: using SquashFS version $sq_version"
	cd "$src"
	echo $modfs_version > squashfs-root/etc/.modfs_version
	sq_mksquashfs squashfs-root "$target" -info -b $blocksize $endian -force-uid 0 -force-gid 0
	rc=$?
	cd "$popd"
	debug "pack_squashfs: exiting, rc=$rc"
	return $rc
}
#
# check, if an option is supported
# $1 - option to look for
# $2 - options from script
is_supported()
{
	local option="$1" options="$2" opt rc=0
	for opt in $options; do
		curr="$opt"
		if [ $(expr index "\(" "$opt") -gt 0 ]; then
			opt="${opt%%(*)}"
		fi
		if [ x"$opt" == x"$option" ]; then
			echo "$curr"
			rc=1
			break
		fi
	done
	debug "is_supported: option=$option, from=$options, rc=$rc"
	return $rc
}
#
# get version values from unpacked image
# $1 - target directory
#
extract_values_from_image()
{
	$bb sh $getversionvaluesscript "$1" -m MODFS_
}
#
# get the kernel version from target system
# $1 - target directory
get_target_kernel_version()
{
	local rootdir="$1"
	local rc=0
	local version
	version="$(extract_values_from_image "$rootdir" | $bb sed -n -e "s|^MODFS_KernelVersion=\"\(.*\)\"\$|\1|p")"
	debug "get_target_kernel_version: result=\"$version\", rc=$rc"
	echo "TARGET_KERNEL_VERSION=\"$version\""
}
#
# get the FRITZ!OS version from target system
# $1 - target directory
get_target_system_version()
{
	local rootdir="$1"
	local rc=0
	local version
	local subversion
	local date
	local values
	values="$(extract_values_from_image "$rootdir")"
	version="$(printf "%s\n" "$values" | $bb sed -n -e "s|^MODFS_Version=\"\(.*\)\"\$|\1|p")"
	subversion="$(printf "%s\n" "$values" | $bb sed -n -e "s|^MODFS_Subversion=\"\(.*\)\"\$|\1|p")"
	date="$(printf "%s\n" "$values" | $bb sed -n -e "s|^MODFS_Date=\"\(.*\)\"\$|\1|p")"
	debug "get_target_system_version: version=\"$version\", subversion=\"$subversion\", date=\"$date\", rc=$rc"
	echo "TARGET_SYSTEM_VERSION=\"$version\" TARGET_SYSTEM_SUBVERSION=\"$subversion\" TARGET_SYSTEM_DATE=\"$date\""
}
#
# get the FRITZ!OS brandings from target system
# $1 - target directory
get_target_brandings()
{
	local rootdir="$1"
	local rc=0
	local brandings
	brandings="$(extract_values_from_image "$rootdir" | $bb sed -n -e "s|^MODFS_Brandings=\"\(.*\)\"\$|\1|p")"
	debug "get_target_brandings: brandings=\"$brandings\", rc=$rc"
	printf "%s\n" "$brandings"
}
#
# get the FRITZ!OS brandings from target system
# $1 - target directory
get_first_branding()
{
	local brandings="$1"
	for branding in $brandings; do
		debug "get_first_branding: brandings=\"$brandings\", branding=\"$branding\", rc=$rc"
		printf "%s\n" "$branding"
		return
	done
}
#
# execute a modscript without further user interaction
# $1 - script name
# $2 - root file system directory
# $3 - mode (auto / onrequest)
#
execute_modscript()
{
	local script="$1" scriptname="${script##*/}" rootdir="$2" mode="$3" rc=0 supports name language uselang languages header opt msg
	debug "execute_modscript: script=$script, root=$rootdir, mode=$mode"
	header="$($bb sed -n -e "1p" "$script")"
	if [ x"$header" == x"# MODFS_MODSCRIPT" ]; then
		supports="$($bb sed -n -e "s/^# SUPPORTS \(.*\)/\1/p" "$script")"
		name="$($bb sed -n -e "s/^# NAME \(.*\)/\1/p" "$script")"
		name="${name// /\\ }"
		if [ ${#name} -gt 0 -a ${#supports} -gt 0 ]; then
			if [ x"$mode" == xauto ]; then
				echo -e "$(get_localized $lang 172 "$name")" 1>&2
				progress 1 173
			fi
			language="$(is_supported 'language' "$supports")"
			if [ $? -eq 1 ]; then
				languages="${language##language(}"
				languages="${languages%)}"
				uselang=$(IFS=, set -- $languages; for lng in $@; do [ $lng == $lang ] && echo $lng && break; done)
				if [ ${#uselang} -eq 0 ]; then
					[ x"$mode" == xauto ] && progress 3 174
					uselang=en
				else
					[ x"$mode" == xauto ] && progress 3 96
				fi
			else
				[ x"$mode" == xauto ] && progress 3 174
				uselang=en
			fi
			if [ x"$mode" == xauto -o x"$mode" == xprecheck ]; then
				rc=0
				progress 1 175
				opt=$(is_supported 'precheck' "$supports")
				if [ $?	-eq 1 ]; then
					# execute pre check
					msg="$(eval export $MODSCRIPT_ENV;$shl $scriptwrapper $script $uselang $rootdir $mode precheck)"
					rc=$?
					if [ $rc -gt 0 ]; then
						progress 3 177 $rc
						echo -e "${msgtext_bold}$msg${msgtext_normal}" 1>&2
					else
						progress 3 96
						[ ${#msg} -gt 0 ] && echo -e "${msgtext_bold}$msg${msgtext_normal}" 1>&2
					fi
				else
					progress 3 176
				fi
				if [ x"$mode" == xprecheck ]; then
					return $rc
				fi
			else
				rc=0
			fi
			if [ $rc -eq 0 ]; then
				progress 1 178
				msg="$(eval export $MODSCRIPT_ENV;$shl $scriptwrapper $script $uselang $rootdir $mode install)"
				rc=$?
				if [ $rc -gt 0 ]; then
					progress 3 177 $rc
					echo -e "${msgtext_bold}$msg${msgtext_normal}" 1>&2
				else
					progress 3 96
					[ ${#msg} -gt 0 ] && echo -e "${msgtext_bold}$msg${msgtext_normal}" 1>&2
					progress 1 179
					opt=$(is_supported 'postcheck' "$supports")
					if [ $?	-eq 1 ]; then
						# execute post check
						msg="$(eval export $MODSCRIPT_ENV;$shl $scriptwrapper $script $uselang $rootdir $mode postcheck)"
						rc=$?
						if [ $rc -gt 0 ]; then
							progress 3 177 $rc
							echo -e "${msgtext_bold}$msg${msgtext_normal}" 1>&2
						else
							progress 3 96
							[ ${#msg} -gt 0 ] && echo -e "${msgtext_bold}$msg${msgtext_normal}" 1>&2
						fi
					else
						progress 3 176
					fi
				fi
			fi
		else
			echo -e "$(get_localized $lang 60 "$scriptname")" 1>&2
			rc=60
		fi
	else
		echo -e "$(get_localized $lang 61 "${scriptname}")" 1>&2
		rc=61
	fi
	echo -e "$(get_localized $lang 180 "${name:-$scriptname}" $rc)" 1>&2
	debug "execute_modscript: exiting, rc=$rc"
	return $rc
}
#
# read description with the specified language from script file
# $1 - language
# $2 - script file
#
get_description()
{
	local language="$1" script="$2" rc=0 append=0 tempdir tempfile line
	tempdir="$(get_temp_dir)"
	tempfile="$tempdir/$($bb date +%s)"
	$bb sed -n -e "/^# MODFS_MODSCRIPT\$/,/^# EOH\$/p" $script | $bb sed -e "1d;\$d;/^# SUPPORTS.*\$/d;/^# NAME.*\$/d" >"$tempfile"
	while read line; do
		if [ x"${line:0:13}" == x"# DESCRIPTION" ]; then
			if [ $language == - ]; then
				if [ x"$line" == x"# DESCRIPTION" ]; then
					append=1
				else
					append=0
				fi
			else
				if [ x"$line" == x"# DESCRIPTION $language" ]; then
					append=1
				else
					append=0
				fi
			fi
		else
			if [ $append -eq 1 ]; then
				description="$description${description:+\n}${line:2}"
			fi
		fi
	done <"$tempfile"
	$bb rm "$tempfile"
	remove_directory "$tempdir"
	debug "get_description: $description"
	echo "$description"
	return $rc
}
#
# ask the user to execute a modscript
# $1 - script name
# $2 - root file system directory
#
execute_optional_modscript()
{
	local script="$1" scriptname="${script##*/}" rootdir="$2" rc=0 supports name language uselang languages header desc msg doit
	debug "execute_optional_modscript: script=$script, root=$rootdir"
	header="$($bb sed -n -e "1p" "$script")"
	if [ x"$header" == x"# MODFS_MODSCRIPT" ]; then
		supports="$($bb sed -n -e "1,/^# EOH\$/s/^# SUPPORTS \(.*\)/\1/p" "$script")"
		name="$($bb sed -n -e "1,/^# EOH\$/s/^# NAME \(.*\)/\1/p" "$script")"
		name="${name// /\\ }"
		if [ ${#name} -gt 0 -a ${#supports} -gt 0 ]; then
			echo -e "$(get_localized $lang 172 "$name")" 1>&2
			pc="$(is_supported 'precheck' "$supports")"
			if [ $? -eq 1 ]; then
				execute_modscript "$script" "$rootdir" precheck
				rc=$?
				debug "execute_optional_modscript: precheck result=$rc"
			else
				rc=0
			fi
			if [ $rc -eq 0 ]; then
				progress 1 173
				language="$(is_supported 'language' "$supports")"
				if [ $? -eq 1 ]; then
					languages="${language##language(}"
					languages="${languages%)}"
					uselang=$(IFS=, set -- $languages; for lng in $@; do [ $lng == $lang ] && echo $lng && break; done)
					if [ ${#uselang} -eq 0 ]; then
						progress 3 174
						uselang=en
					else
						progress 3 96
					fi
				else
					progress 3 174
					uselang=en
				fi
				$bb sleep 1
				desc="$($bb sed -n -e "/^# DESCRIPTION $uselang\$/=" "$script")"
				if [ ${#desc} -eq 0 ]; then
					desc="$($bb sed -n -e "/^# DESCRIPTION\$/=" "$script")"
					if [ ${#desc} -eq 0 ]; then
						desc="$(get_localized $lang 181)"
					else
						desc="$(get_description - "$script")"
					fi
				else
					desc="$(get_description $uselang "$script")"
				fi
				msg="$(get_localized $lang 182 "$name" "%description%")"
				msg="${msg//%description%/$desc}"
				doit=$(ask_yes_or_no n "$msg")
				[ "$doit" = "C" ] && exit 1
				if [ x$doit == xY ]; then
					execute_modscript "$script" "$rootdir" onrequest
				fi
			else
				echo 1>&2
			fi
		else
			echo -e "$(get_localized $lang 60 "${scriptname}")" 1>&2
			rc=60
		fi
	else
		echo -e "$(get_localized $lang 61 "${scriptname}")" 1>&2
		rc=61
	fi
	debug "execute_optional_modscript: exiting, rc=$rc"
	return $rc
}
#
# sort the list of modscripts to ensure execution in order, if a modifications depends on another
# $1 - script list file
#
solve_modscript_dependencies()
{
	local list="$1" scriptsdir="$2"
	$bb sed -n -e "\|^$scriptsdir|p" "$list" | $bb sort
	$bb sed -e "\|^$scriptsdir|d" "$list" | $bb sort
}
#
# prepare the executable flags of modscripts listed in a custom selection file
#
prepare_custom_modscripts_selection()
{
	local rc=0 line state scriptname flags
	debug "prepare_custom_modscripts_selection: looking for custom selection file"
	if [ -f "$scriptpath/$custom_selection_file" ]; then
		while read line; do
			state="${line:0:1}"
			scriptname="${line:1}"
			debug "prepare_custom_modscripts_selection: found line with state '$state' for file '$scriptname'"
			# state is mandatory
			[ ${#state} -eq 0 ] && continue
			# state has to be + (autoexec), ? (optional) or - (ignore/do not use)
			[ x"$state" != x"+" -a x"$state" != x"-" -a x"$state" != x'?' ] && continue
			# scriptname missing
			[ ${#scriptname} -eq 0 ] && continue
			# file exists?
			[ -f "$scriptpath/$scriptname" ] || continue
			flags="a-x"
			if [ "$state" == "+" ]; then
				flags="a+x"
			elif [ "$state" == '?' ]; then
				flags="ug+x,o-x"
			fi
			$bb chmod "$flags" "$scriptpath/$scriptname"
			rc=$?
			debug "prepare_custom_modscripts_selection: chmod done for '$scriptname' (flags='$flags'), rc=$rc"
		done <"$scriptpath/$custom_selection_file"
		rc=0
		debug "prepare_custom_modscripts_selection: done"
	else
		debug "prepare_custom_modscripts_selection: done, no custom file found"
	fi
}
#
# filter to remove script files without ANY executable flag set from STDIN,
# write other file names to STDOUT
#
remove_disabled_scripts()
{
	while read -r script; do
		flags=$($bb stat -c %a $script)
		execute=$(( ( ${flags:2:1} & 1 ) + ( ${flags:1:1} & 1 ) + ( ${flags:0:1} & 1 ) ))
		[ $execute -lt 2 ] && continue
		echo "$script"
	done
}
#
# execute modification scripts
# - only execute scripts, which are "world-executable", while in batch mode
# - execute the other scripts in a 2nd step, asking the user to confirm each one
# $1 - source tree
# $2 - scripts directory
#
modify_rootfs()
{
	local target="$1" scripts="$2" contribs="$3" scriptdirname="$4" rc=0 line lines lrc filelist script donelist tmpdir flags execute
	tmpdir="$(get_temp_dir)"
	# short stop to ensure an unique temporary directory name (contains the unix time)
	$bb sleep 1
	debug "modify_rootfs: starting, target=$target, scripts=$scripts, contribs=$contribs"
	FRITZOS_VERSION="$(get_target_system_version "$unpack_directory/$squashfsdirname")"
	KERNEL_VERSION="$(get_target_kernel_version "$unpack_directory/$squashfsdirname")"
	BRANDINGS="$(get_target_brandings "$unpack_directory/$squashfsdirname")"
	BRANDING="$(get_first_branding "$BRANDINGS")"
	gvv="$(extract_values_from_image "$target" | sed -e ":x;\$!N;s/\n/ /;tx")"
	MODSCRIPT_ENV="$KERNEL_VERSION $FRITZOS_VERSION TARGET_BRANDINGS=\"$BRANDINGS\" TARGET_BRANDING=\"$BRANDING\" TMP=\"$tmpdir\" TMPDIR=\"$tmpdir\" $gvv"
	prepare_custom_modscripts_selection
	list="$tmpdir/scriptfiles"
	filelist="$tmpdir/scripts"
	donelist="$tmpdir/executed"
	$bb find "$scripts" -follow -xdev -type f 2>/dev/null >"$list"
	if ! [ -z "$contribs" ]; then
		for dir in $($bb find "$contribs" -name "$scriptdirname" -maxdepth 2 -follow -xdev -type d 2>/dev/null); do
			$bb find "$dir" -follow -xdev -type f 2>/dev/null >>"$list"
		done
	fi
	[ -s "$list" ] && lines=$($bb sed -n -e "\$=" "$list") || lines=0
	[ $lines -gt 0 ] && solve_modscript_dependencies "$list" "$scripts" | remove_disabled_scripts >"$filelist" || touch "$filelist"
	debug "solve_dependencies: final modscripts list"
	cat "$filelist" | $debugoutput
	[ -s "$filelist" ] && lines=$($bb sed -n -e "\$=" "$filelist") || lines=0
	line=0
	while [ $line -lt $lines ]; do
		let line+=1
		script="$($bb sed -n -e "${line}p" "$filelist")"
		flags=$($bb stat -c %a $script)
		execute=$(( ( ${flags:2:1} & 1 ) + ( ${flags:1:1} & 1 ) + ( ${flags:0:1} & 1 ) ))
		[ $execute -lt 3 ] && continue
		echo "\|^$script\$|d" >>$donelist
		execute_modscript "$script" "$target" auto
		lrc=$?
		[ $lrc -gt $rc ] && rc=$lrc
	done
	[ $line -gt 0 -a -s "$donelist" ] && $bb sed -f "$donelist" -i "$filelist"
	[ -s "$filelist" ] && lines=$($bb sed -n -e "\$=" "$filelist") || lines=0
	line=0
	while [ $line -lt $lines ]; do
		let line+=1
		script="$($bb sed -n -e "${line}p" "$filelist")"
		flags=$($bb stat -c %a $script)
		execute=$(( ( ${flags:1:1} & 1 ) + ( ${flags:0:1} & 1 ) ))
		[ $execute -lt 2 ] && continue
		execute_optional_modscript "$script" "$target"
		lrc=$?
		[ $lrc -gt $rc ] && rc=$lrc
	done
	remove_directory "$tmpdir"
	debug "modify_rootfs: exiting, rc=$rc"
	return $rc
}
#
# extract squash file system from firmware image
# $1 - source firmware image
# $2 - target file name and path (path has to be a valid directory)
#
extract_rootfs_from_firmware()
{
	local src="$1" target="$2" tmp rc mp tmpdir
	debug "extract_rootfs_from_firmware: src=$src, target=$target"
	tmpdir="$(get_temp_dir)"
	tmp="$tmpdir/outerfs"
	extract_filesystem "$src" "$tmp"
	rc=$?
	if [ $rc -ne 0 ]; then
		rc=39
	else
		$bb mkdir "$tmpdir/mp"
		fstype=$(detect_image_filesystem "$tmp")
		rc=$?
		if [ $rc -eq 0 ]; then
			if [ "$fstype" == "ext2" -o "$fstype" == "sqfs_dummy256_ext2" ]; then
				# ext2 image with AVM's dummy header
				mount_ext2_image "$tmp" "$tmpdir/mp" "$fstype"
				rc=$?
			else
				$bb mount "$tmp" "$tmpdir/mp" 2>/dev/null
				rc=$?
				if [ $rc -ne 0 ]; then
					# try to extract with unsquashfs3, if this is a 3.xx kernel based
					# system without knowledge about SquashFS3 format while mounting
					kernelversion=$($bb uname -r)
					kernelversion=${kernelversion%%.*}
					if [ $kernelversion -eq 3 -a x"$fstype" == x"squashfs3" ]; then
						unpack_squashfs "$tmp" "${target%/*}" "$rootfsname" 2>&1 >/dev/null
						rc=$?
						if [ $rc -eq 0 ]; then
							$bb mv "${target%/*}/$squashfsdirname/$rootfsname" "${target}"
							rc=$?
							$bb rmdir "${target%/*}/$squashfsdirname"
							remove_directory "$tmpdir"
							debug "extract_rootfs_from_firmware: exiting, rc=$rc"
							return $rc
						fi
					fi
				fi
			fi
			if [ $rc -ne 0 ]; then
				rc=40
			else
				$bb cp -a "$tmpdir/mp/$rootfsname" "$target"
				rc=$?
				if [ $rc -ne 0 ]; then
					rc=41
				fi
				$bb umount -d "$tmpdir/mp"
			fi
		fi
	fi
	$bb rm $tmp 2>/dev/null
	remove_directory "$tmpdir"
	debug "extract_rootfs_from_firmware: exiting, rc=$rc"
	return $rc
}
#
# set SquashFS version from image type
# $1 - source image
#
get_squashfs_tools_version()
{
	local src="$1" rc fstype major
	fstype=$(detect_image_filesystem "$src")
	rc=$?
	if [ $rc -eq 0 ]; then
		if [ "${fstype:0:8}" == "squashfs" ]; then
			major=${fstype#squashfs}
			echo $major
			rc=0
		fi
	fi
	debug "get_squashfs_tools_version: src=$src, version=$major"
	return $rc
}
#
# mount ext2 image using losetup with offset to avoid doubling
# the space needed to extract (as with 'dd') or use the "dd"-way
# if no losetup binary is available
# $1 - source image
# $2 - target directory name
#
mount_ext2_image()
{
	local src="$1" mp="$2" fstype="$3" rc=202 loopdev
	debug "mount_ext2_image: src=$src, mp=$mp, type=$fstype"
	if [ "$fstype" == "sqfs_dummy256_ext2" ]; then
		$bb losetup -a >/dev/null 2>&1
		if [ $? -eq 0 ]; then
			$bb losetup -r -f -o 256 $src 2>/dev/null
			rc=$?
			debug "mount_ext2_image: loop device setup (-r -f -o 256) for $src, rc=$rc"
			[ $rc -eq 0 ] && loopdev=$($bb losetup -a | $bb sed -n -e "s|^\([^ ]*\):.*${src:0:63}.*\$|\1|p")
			if [ ${#loopdev} -eq 0 ]; then
				debug "mount_ext2_image: unable to find the loop device backed by our image file, aborting"
				losetup -a 2>&1 | $debugoutput
				rc=202
			fi
		else
			debug "mount_ext2_image: no losetup found, using dd to remove dummy block"
			$bb dd if="$src" of="$src.ext2" bs=256 skip=1 conv=fsync,sync 2>/dev/null
			rcdd=$?
			rcmv="?"
			if [ $rcdd -eq 0 ]; then
				$bb mv "$src.ext2" "$src"
				rcmv=$?
			fi
			debug "mount_ext2_image: dummy header removed, dd=$rcdd, mv=$rcmv"
			loopdev="$src"
			rc=0
		fi
	else
		loopdev=$src
		rc=0
	fi
	if [ $rc -eq 0 ]; then
		$bb mount -o ro "$loopdev" "$mp" 2>/dev/null
		rc=$?
		debug "mount_ext2_image: mounting $loopdev to $mp, rc=$rc"
	fi
	debug "mount_ext2_image: exiting, rc=$rc"
	return $rc
}
#
# extract squash file system from outer image
# $1 - source image
# $2 - target file name and path (path has to be a valid directory)
#
extract_rootfs_from_outer_filesystem()
{
	local src="$1" target="$2" tmp rc mp tmpdir version kernelversion
	debug "extract_rootfs_from_outer_filesystem: src=$src, target=$target"
	fstype=$(detect_image_filesystem "$src")
	rc=$?
	if [ $rc -eq 0 ]; then
		tmpdir="$(get_temp_dir)"
		if [ "$fstype" == "ext2" -o "$fstype" == "sqfs_dummy256_ext2" ]; then
			# ext2 image with AVM's dummy header
			mount_ext2_image "$src" "$tmpdir" "$fstype"
			rc=$?
		else
			$bb mount "$src" "$tmpdir" 2>/dev/null
			rc=$?
			if [ $rc -ne 0 ]; then
				# try to extract with unsquashfs3, if this is a 3.xx kernel based
				# system without knowledge about SquashFS3 format while mounting
				kernelversion=$($bb uname -r)
				kernelversion=${kernelversion%%.*}
				if [ $kernelversion -eq 3 -a x"$fstype" == x"squashfs3" ]; then
					unpack_squashfs "$src" "${target%/*}" "$rootfsname" 2>&1 >/dev/null
					rc=$?
					if [ $rc -eq 0 ]; then
						$bb mv "${target%/*}/$squashfsdirname/$rootfsname" "${target}"
						rc=$?
						$bb rmdir "${target%/*}/$squashfsdirname"
						remove_directory "$tmpdir"
						debug "extract_rootfs_from_outer_filesystem: exiting, rc=$rc"
						return $rc
					fi
				fi
			fi
		fi
		if [ $rc -ne 0 ]; then
			rc=40
		else
			$bb cp -a "$tmpdir/$rootfsname" "$target"
			rc=$?
			if [ $rc -ne 0 ]; then
				rc=41
			fi
			$bb umount -d "$tmpdir"
		fi
		remove_directory "$tmpdir"
	fi
	debug "extract_rootfs_from_outer_filesyste: exiting, rc=$rc"
	return $rc
}
#
# extract kernel image from firmware image
# $1 - source firmware image
# $2 - target file name and path (path has to be a valid directory)
#
extract_kernel()
{
	local src="$1" target="$2" tmp rc mp tmpdir
	debug "extract_kernel: src=$src, target=$target"
	$bb tar -xOf "$src" "$firmware_kernel_image" >"$target" 2>/dev/null
	rc=$?
	if [ $rc -ne 0 ]; then
		rc=62
	fi
	debug "extract_kernel: exiting, rc=$rc"
	return $rc
}
#
# extract filesystem image from firmware image
# $1 - source firmware image
# $2 - target file name and path (path has to be a valid directory)
#
extract_filesystem()
{
	local src="$1" target="$2" tmp rc mp tmpdir
	debug "extract_filesystem: src=$src, target=$target"
	$bb tar -xOf "$src" "$firmware_filesystem_image" >"$target" 2>/dev/null
	rc=$?
	if [ $rc -ne 0 ]; then
		rc=39
	fi
	debug "extract_filesystem: exiting, rc=$rc"
	return $rc
}
#
# get system version
# $1 - system root
#
get_system_version()
{
	local rootdir="$1" version subversion date rc=0 var
	version_major="$($bb sed -n -e "s/^export CONFIG_VERSION_MAJOR=\"\(.*\)\"\$/\1/p" "$rootdir/etc/init.d/rc.conf" | $bb sed -n -e "\$p")"
	if [ -z "$($bb sed -n -e "/^[ \t]*export FIRMWARE_VERSION=/p" "$rootdir/etc/version")" ]; then
		major="$($bb sed -n -e "s/^export CONFIG_VERSION_MAJOR=\"\?\([^\"]*\)\"\?\$/\1/p" "$rootdir/etc/init.d/rc.conf" | sed -e "/^10\$/d")"
		for var in version subversion; do
			eval "$($bb sed -n -e "s/^export CONFIG_$(uppercase $var)=\"\?\([^\"]*\)\"\?\$/$var=\"\1\"/p" "$rootdir/etc/init.d/rc.conf")"
		done
		date="$(date +%d.%m.%Y\ %H:%M:%S -d @$(stat -c %Y "$rootdir/etc/version"))"
		version="$major.$version"
	else
		for var in version subversion date; do
			eval "$($bb sed -n -e "s/^export FIRMWARE_$(uppercase $var)=\"\?\([^\"]*\)\"\?\$/$var=\"\1\"/p" "$rootdir/etc/version" | $bb sed -e "s/CONFIG_VERSION_MAJOR/version_major/")"
		done
		[ ${#subversion} -eq 0 ] && subversion="$($bb sed -n -e "/--project)/N;s|\n||p" "$rootdir/etc/version" | $bb sed -n -e "s|.*echo \(.*\)|-\1|p")"
	fi
	debug "get_system_version: version=\"$version\", subversion=\"$subversion\", date=\"$date\", rc=$rc"
	echo "${version}${subversion}"
}
#
# download firmware file from manufacturer
# $1 - target file name
# $2 - source URL
#
download_firmware()
{
	local target="$1" source="$2" rc=0
	debug "download_firmware: target=$target, source=$source"
	$bb wget -q -O "$target" "$source" 2>/dev/null
	rc=$?
	if [ $rc -ne 0 ]; then
		rc=42
	else
		if [ $($bb stat -c %s "$target") -eq 0 ]; then
			rc=43
		else
			debug "download_firmware: $($bb stat -c %s "$target") bytes downloaded"
		fi
	fi
	debug "download_firmware: exiting, rc=$rc"
	return $rc
}
#
# try to verify the signature of a downloaded image file
# $1 - image file name
#
try_to_check_integrity()
{
	local target="$1" rc=205 opwd
	debug "try_to_check_integrity: target=$target"
	progress 1 206
	if [ -f $(scriptdir)/check_image_signature ]; then
		opwd="$($bb pwd)"
		cd "$(scriptdir)"
		$shl $scriptwrapper check_image_signature check
		rc=$?
		if [ $rc -eq 0 ]; then
			$shl $scriptwrapper check_image_signature verify "$target"
			rc=$?
			if [ $rc -eq 0 ]; then
				progress 3 96
				debug "try_to_check_integrity: integrity check passed"
				rc=0
			else
				progress 3 97
				debug "try_to_check_integrity: integrity check failed, error code was $rc"
				rc=205
			fi
		else
			progress 3 95
			debug "try_to_check_integrity: some components are missing (rc=$rc), unable to verify signature"
			rc=0
		fi
		cd "$opwd"
	else
		progress 3 95
		debug "try_to_check_integrity: script is not present"
		rc=0
	fi
	debug "try_to_check_integrity: exiting, rc=$rc"
	return $rc
}
#
# check space value for human readable format
# - the ash shell at the box is limited to 32-bit arithmetics, GB units are impossible
# $1 - space value (n, nK or nM)
#
get_numeric_space_value()
{
	local rc=0 number=$1 size=0 len last
	if [ ${#number} -eq 0 ]; then
		rc=127
	else
		last=${number:$(( ${#number} - 1 )):1}
		len=$(( ${#number} - 1 ))
		num=${number:0:$len}
		if [ $last == K ]; then
			size=$(( $num * 1024 ))
		else
			if [ $last == M ]; then
				size=$(( $num * 1024 * 1024 ))
			else
				size=$number
			fi
		fi
	fi
	echo $size
	return $rc
}
#
# check free tmpfs space
# $1 - free space needed for rc=0
# $2 - free space needed for rc=1
#
check_free_tmpfs()
{
	local rc=0 size bs free freespace rc1 rc2
	wanted=$(get_numeric_space_value $1)
	rc1=$?
	needed=$(get_numeric_space_value $2)
	rc2=$?
	debug "check_free_tmpfs: wanted=$wanted, needed=$needed"
	if [ $rc1 -eq 0 -a $rc2 -eq 0 ]; then
		bs=$($bb stat -c %S -f $tmpfsbasedir)
		free=$($bb stat -c %f -f $tmpfsbasedir)
		freespace=$(( bs * free ))
		if [ $freespace -lt $wanted ]; then
			if [ $freespace -lt $needed ]; then
				rc=2
			else
				rc=1
			fi
		else
			rc=0
		fi
	else
		let rc=rc1+rc2
	fi
	debug "check_free_tmpfs: exiting, rc=$rc"
	return $rc
}
#
# check, if the specified path is on volatile storage
#
is_tmpfs()
{
	local path="$1"
	type=$($bb stat -c %T -f "$path")
	if [ x$type == x"tmpfs" ]; then
		echo 1
	else
		echo 0
	fi
	debug "is_tmpfs: path=$path, fs=$type"
}
#
# get nand file system mount point
#
get_nand_mountpoint()
{
	local rc=0 nandmajor nandminor device mountpoint type options x y
	if [ $CONFIG_NAND == y ]; then
		nandminor=$(get_mtd_by_name $nandname)
		if [ ${#nandminor} -gt 0 ]; then
			nandmajor=$($bb sed -n -e "s/^ *\([0-9]*\) $mtdblockname/\1/p" /proc/devices)
			rc=1
			while read device mountpoint type options x y; do
				if [ x"$($bb stat -c %F $device 2>/dev/null)" == x"block special file" ]; then
					if [ $(( 0x$($bb stat -c %t $device 2>/dev/null) )) -eq $nandmajor ]; then
						if [ $(( 0x$($bb stat -c %T $device 2>/dev/null) )) -eq $nandminor ]; then
							echo $mountpoint
							rc=0
							break
						fi
					fi
				fi
			done </proc/mounts
		else
			rc=2
		fi
	else
		rc=2
	fi
	[ $rc -eq 0 ] && debug "get_nand_mountpoint: location=$mountpoint" || debug "get_nand_mountpoint: no NAND device found"
	return $rc
}
#
# check free nand space
# $1 - free space needed
#
check_free_nand()
{
	local rc=0 size bs free freespace
	size=$(get_numeric_space_value $1)
	rc=$?
	if [ $rc -eq 0 ]; then
		nand=$(get_nand_mountpoint)
		bs=$($bb stat -c %S -f $nand)
		free=$($bb stat -c %f -f $nand)
		freespace=$(( bs * free ))
		if [ $freespace -lt $size ]; then
			rc=1
		else
			echo "$nand:$freespace"
			rc=0
		fi
	fi
	debug "check_free_nand: size=$size, nand=$nand, free=$freespace"
	return $rc
}
#
# find USB device mount point(s)
# - print all network (block devices) or USB mount points
#
get_possible_usb_mountpoints()
{
	local device mountpoint type options x y major dev i count=0
	while read device mountpoint type options x y; do
		if [ x"$($bb stat -c %F $device 2>/dev/null)" == x"block special file" ]; then
			major=$(( 0x$($bb stat -c %t $device 2>/dev/null) ))
			dev=$($bb sed -e "1,/^Block devices:/d" /proc/devices | $bb sed -n -e "s/^ *$major \(.*\)/\1/p")
			i=$(index_of_item "$dev" "loop $mtdblockname")
			if [ $? -eq 1 ]; then
				# not on loop or mtdblock - USB or network
				echo $mountpoint
				debug "get_possible_usb_mountpoints: on=$mountpoint"
				let count+=1
			fi
		fi
	done </proc/mounts
	debug "get_possible_usb_mountpoints: count=$count"
	return $count
}
#
# check space on mount points at stdin
# - stdin has to contain one line for each mount point of a file system to check
# - stdout will contain a list of all mount points with enough room and the free space available there
# $1 - free space needed
#
check_space()
{
	local needed outpath mp bs free_blocks blocks_in_K free_size unit needed_blocks
	needed=$(get_numeric_space_value $1)
	debug "check_space: needed=$needed"
	while read mp; do
		bs=$($bb stat -c %S -f $mp)
		free_blocks=$($bb stat -c %f -f $mp)
		# 32-bit arithmetics on box are a little bit annoying
		let size=$(( bs * free_blocks ))
		if [ ${#size} -gt 6 ]; then
			if [ $bs -gt 1024 ]; then
				blocks_in_K=$(( $bs / 1024 ))
				let size=$(( blocks_in_K * free_blocks ))
				if [ ${#size} -gt 6 ]; then
					# very much free space, let's try it with MBytes
					free_size=$(( free_blocks * ( bs / 1024 ) ))
					unit=K
					needed_blocks=$(( needed / bs ))
				else
					free_size=$(( blocks_in_K * free_blocks ))
					unit=K
					needed_blocks=$(( needed / bs ))
				fi
			else # block size is lower than 1K, awesome ... free_blocks seems to be very large
				free_size=$(( free_blocks / ( 1024 / bs ) ))
				unit=K
				needed_blocks=$(( needed / bs ))
			fi
		else
			free_size=$(( bs * free_blocks ))
			unit=""
			needed_blocks=$(( needed / bs ))
		fi
		if [ $free_blocks -ge $needed_blocks ]; then
			let mpcount+=1
			outpath="$outpath $mp:$free_size$unit"
		fi
	done
	debug "check_space: $outpath"
	echo "$outpath"
}
#
# find any place with enough free storage to host our ext3 image
# $1 - free space needed
# $2 - nonand -> ignore NAND storage, withnand -> NAND storage *and* other places, acceptnand -> NAND storage is able to satisfy the requirements
#
find_free_storage_space()
{
	local rc=0 needed mp mpcount=0 out bs free_blocks free_size needed_blocks unit
	needed=$(get_numeric_space_value $1)
	debug "find_free_storage_space: needed=$needed, accept=$2"
	rc=$?
	if [ $rc -eq 0 ]; then
		if [ x$2 == xnonand ]; then
			rc=1
		else
			out=$(check_free_nand $1)
			rc=$?
			if [ $rc -eq 0 ]; then
				if [ x$2 == xacceptnand ]; then
					rc=0
				else
					if [ x$2 == xwithnand ]; then
						rc=1
					fi
				fi
			fi
		fi
		if [ $rc -ne 0 ]; then
			out="$out${out:+ }$(get_possible_usb_mountpoints | check_space $needed)"
			if [ ${#out} -gt 0 ]; then
				echo "$out"
				rc=0
			else
				rc=1
			fi
		else
			echo "$out"
		fi
	fi
	debug "find_free_storage_space: $out"
	debug "find_free_storage_space: exiting, rc=$rc"
	return $rc
}
#
# get a readable output for free space
# $1 - space to convert to a human readable format (at least KByte, better MByte)
#
get_display_space()
{
	local input="$1" len last num output=0
	len=$(( ${#input} - 1 ))
	last=${input:$len:1} num=${input:0:$len}
	if [ $last == K ]; then
		output=$(( num / 1024 ))
	else
		if [ $last == M ]; then
			output=$num
		else
			num=$(( $num$last ))
			output=$(( num / 1024 / 1024 ))
		fi
	fi
	if [ $output -gt 10240 ]; then
		echo "$(( output / 1024 )) GB"
	else
		echo "$output MB"
	fi
	return
}
#
# ask the user to select one of the available working directories
# $1 - available mount points
#
get_path_selection()
{
	local mps="$1" msglist="$2" msg1 msg2 msg3 msg4 msg5 msg6 msg7 rc=0 letter letters="abcdefghijklmnopqrstuvwxyz" index
	set -- $msglist
	msg1=$1
	msg2=$2
	msg3=$3
	msg4=$4
	msg5=$5
	msg6=$6
	msg7=$7
	echo "$(get_localized $lang $msg1)" 1>&2
	while [ 1 -eq 1 ]; do
		echo -e "\n$(get_localized $lang $msg2)\n" 1>&2
		index=0
		answers=""
		for mp in $mps; do
			space="${mp##*:}"
			path="${mp%%:*}"
			letter=${letters:$index:1}
			freespace=$(get_display_space $space)
			device=$($bb sed -n -e "s|^\([^ ]*\) $path .*|\1|p" /proc/mounts)
			filesystem=$($bb sed -n -e "s|^[^ ]* $path \([^ ]*\) .*|\1|p" /proc/mounts)
			[ $filesystem == fuseblk ] && filesystem="NTFS_via_fuse"
			let index+=1
			line="$(get_localized $lang $msg3 "$letter" "$device" "$filesystem" "$path" "$freespace")"
			echo -e "$line" 1>&2
			answers=$answers$letter
		done
		echo -e "$(get_localized $lang $msg5)" 1>&2
		echo -ne "\n$(get_localized $lang $msg4) " 1>&2
		while read -n 10 -s -t 1; do :; done
		read -n 1 -s selection
		case "$selection" in
			[qQ])
				echo -e "$selection$(get_localized $lang $msg7)" 1>&2
				return 1
				;;
			*)
				if [ ${#selection} -gt 0 ]; then
					if [ $(expr index $selection $answers$(uppercase $answers)) -gt 0 ]; then
						break
					fi
				fi
				echo -e "$selection\n$(get_localized $lang $msg6)" 1>&2
				continue
				;;
		esac
		break
	done
	echo -ne "$selection\n\n$msgtext_normal" 1>&2
	index=0
	for mp in $mps; do
		letter=${letters:$index:1}
		if [ $letter == $selection -o $(uppercase $letter) == $selection ]; then
			echo $mp
			debug "get_path_selection: selection=$letter, mp=$mp"
			return 0
		fi
		let index+=1
	done
	debug "get_path_selection: exiting, rc=1"
	return 1
}
#
# find a convenient storage place to fulfill the specified space requirements
# - the allowed places to search are 'tmpfs', 'nand', 'storage' in any order (2nd argument)
# $1 - space needed
# $2 - order of space to search
#
find_free_space()
{
	local wanted=$1 order="$2" rc=1 path
	debug "find_free_space: wanted=$wanted, order=$order"
	for place in $order; do
		case $place in
			tmpfs)
				check_free_tmpfs $wanted $wanted
				rc=$?
				if [ $rc -eq 0 ]; then
					echo $tmpfsbasedir
					debug "find_free_space: tmpfs=$tmpfsbasedir"
					break
				fi
				;;
			nand)
				path=$(check_free_nand $wanted)
				rc=$?
				if [ $rc -eq 0 ]; then
					echo ${path%%:*}
					debug "find_free_space: nand=$path"
					break
				fi
				;;
			storage)
				path="$(find_free_storage_space $wanted nonand)"
				rc=$?
				if [ $rc -eq 0 ]; then
					count=0
					for mp in $path; do
						let count+=1
					done
					if [ $count -gt 1 ]; then
						path=$(get_path_selection "$path" "122 123 124 125 126 127 131")
						rc=$?
						if [ $rc -eq 0 ]; then
							echo ${path%%:*}
							debug "find_free_space: storage=$path"
							break
						fi
					else
						debug "find_free_space: storage=$path"
						echo ${path%%:*}
						break
					fi
				fi
				;;
			*)
				;;
		esac
	done
	debug "find_free_space: exiting, rc=$rc"
	return $rc
}
#
# find mount point for the specified path
# $1 - path below the needed mount point
#
get_mountpoint()
{
	local path="$1" rc=0
	while [ ${#path} -gt 0 ]; do
		dev="$($bb sed -n -e "s|^\([^ \t]*\) $path \(.*\) \(.*\) \(.\) \(.\)|\1|p" /proc/mounts)"
		if [ ${#dev} -gt 0 ]; then
			break
		else
			path="${path%/*}"
		fi
	done
	echo $path
	debug "get_mount_point: path=$1, mp=$path"
	return $rc
}
#
# let the user select a non-volatile storage place with enough free space
#
get_persistent_path()
{
	local wanted rc=0 count
	wanted=$(get_numeric_space_value $1)
	path="$(find_free_storage_space $wanted withnand)"
	debug "get_persistent_path: wanted=$wanted"
	rc=$?
	if [ $rc -eq 0 ]; then
		count=0
		for mp in $path; do
			let count+=1
		done
		if [ $count -gt 1 ]; then
			path=$(get_path_selection "$path" "136 137 124 138 126 127 139")
			rc=$?
			if [ $rc -eq 0 ]; then
				echo ${path%%:*}
				debug "get_persistent_path: $path"
			fi
		else
			echo ${path%%:*}
			debug "get_persistent_path: $path"
		fi
	fi
	debug "get_persistent_path: exiting, rc=$rc"
	return $rc
}
#
# check a possible squashfs image file
# $1 - image file name
#
check_squashfs_image()
{
	local squashfsimage="$1" rc=0 sq_version fstype
	debug "check_squashfs_image: src=$squashfsimage"
	progress 1 165 "$squashfsimage"
	fstype="$(detect_image_filesystem "$squashfsimage")"
	if [ $? -eq 0 ]; then
		if [ "${fstype:0:8}" == "squashfs" ]; then
			sq_version=$(get_squashfs_tools_version "$squashfsimage")
			sq_unsquashfs -stat "$squashfsimage" 2>/dev/null 1>&2
			rc=$?
			if [ $rc -ne 0 ]; then
				progress 3 166
				echo -e "$(get_localized $lang 162 "$squashfsimage")" 1>&2
				debug "check_squashfs_image: error reading superblock"
				rc=1
			else
				progress 3 96
				debug "check_squashfs_image: found a SquashFS image with version $sq_version"
				rc=0
			fi
		else
			debug "check_squashfs_image: not a SquashFS image"
			rc=1
		fi
	else
		debug "check_squashfs_image: unable to detect image type"
		rc=1
	fi
	debug "check_squashfs_image: exiting, rc=$rc"
	return $rc
}
#
# check a possible firmware image file
# $1 - image file name
#
check_firmware_image()
{
	local firmwareimage="$1" rc=0
	debug "check_firmware_image: src=$firmwareimage"
	if [ $no_sigcheck -ne 1 ]; then
		try_to_check_integrity "$firmwareimage"
		rc=$?
		if [ $rc -ne 0 ]; then
			return $rc
		fi
	fi
	progress 1 167 "$firmwareimage"
	$bb tar -tf "$firmwareimage" "$firmware_filesystem_image" 2>/dev/null 1>&2
	rc=$?
	if [ $rc -ne 0 ]; then
		progress 3 166
		# nope
		echo -e "$(get_localized $lang 163 "$firmwareimage")" 1>&2
		rc=1
	else
		progress 3 96
		# ok, let's get the filesystem image from it
		working_directory="$(get_working_directory $extract_space_needed "tmpfs $nand storage")"
		rc=$?
		if [ $rc -ne 0 ]; then
			echo -e "$(get_localized $lang $rc)" 1>&2
			return $rc
		fi
		image_directory="$working_directory/$($bb date +%s)"
		$bb mkdir -p "$image_directory"
		echo "$bb rm -r $image_directory" >>$tempfilelist
		progress 1 132
		extract_rootfs_from_firmware "$firmwareimage" "$image_directory/$rootfsname"
		rc=$?
		if [ $rc -ne 0 ]; then
			progress 3 97
			echo -e "$(get_localized $lang 163 "$firmwareimage")" 1>&2
			rc=1
		else
			# we've got a squashfs image file
			progress 3 96
			squashfsimage="$image_directory/$rootfsname"
			echo "$squashfsimage"
			rc=0
		fi
	fi
	debug "check_firmware_image: exiting, rc=$rc"
	return $rc
}
#
# check the embedded version script of a squashfs image
# $1 - image file name
#
check_squashfs_file_version()
{
	local squashfsimage="$1" rc=0 working_directory checkdir imageversion sq_version
	debug "check_squashfs_file_version: src=$squashfsimage"
	# check squashfs version
	working_directory="$(get_working_directory 1M "tmpfs $nand storage")"
	rc=$?
	if [ $rc -ne 0 ]; then
		echo -e "$(get_localized $lang $rc)" 1>&2
		debug "check_squashfs_file_version: exiting, rc=$rc"
		exit $rc
	fi
	progress 1 168 $squashfsimage
	checkdir="$(get_temp_dir)"
	sq_version=$(get_squashfs_tools_version "$squashfsimage")
	sq_unsquashfs -dest "$checkdir/test" "$squashfsimage" "/etc/version" "/etc/init.d/rc.conf"  2>/dev/null 1>&2
	if [ -f "$checkdir/test/etc/version" ] && [ -f "$checkdir/test/etc/init.d/rc.conf" ]; then
		# check image version
		imageversion="$(get_system_version "$checkdir/test")"
		if [ x$imageversion == x$(get_system_version) ]; then
			progress 3 96
			rc=0
		else
			progress 3 97
			echo -e "$(get_localized $lang 164 "$squashfsimage")" 1>&2
			rc=1
		fi
	else
		# no version file at image, usually not an original
		progress 3 97
		echo -e "$(get_localized $lang 162 "$squashfsimage")" 1>&2
		rc=1
	fi
	remove_directory "$checkdir"
	debug "check_squashfs_file_version: version=$imageversion"
	debug "check_squashfs_file_version: exiting, rc=$rc"
	return $rc
}
#
# find an appropriate image file at the specified device
# $1 - mount point
#
find_image_file()
{
	local mp="$1" squashfsimage firmwareimage rc=0 image_directory working_directory
	debug "find_image_file: mp=$mp"
	if [ -f "$mp/$rootfsname" ]; then
		# possibly a squashfs as pattern
		squashfsimage="$mp/$rootfsname"
		check_squashfs_image "$squashfsimage"
		rc=$?
	else
		if [ -f "$mp/$firmwarestoragename" ]; then
			# possibly a firmware image as pattern
			firmwareimage="$mp/$firmwarestoragename"
			squashfsimage="$(check_firmware_image "$firmwareimage")"
			rc=$?
		else
			rc=1
		fi
	fi
	if [ $rc -eq 0 ]; then
		check_squashfs_file_version "$squashfsimage"
		rc=$?
		[ $rc -eq 0 ] && echo "$squashfsimage"
	fi
	debug "find_image_file: exiting, rc=$rc"
	return $rc
}
#
# let the user select a non-volatile storage place with an existing squashfs image
#
get_input_image_path()
{
	local rc=0 count notfound=0 path mp squashfsimage firmwareimage working_directory image_directory checkdir imageversion space letter answers filesystem device letters="abcdefghijklmno" pathinput=0 breaknow=0 pathto
	path="$(find_free_storage_space 1K withnand)"
	rc=$?
	if [ $rc -eq 0 ]; then
		count=0
		for mp in $path; do
			let count+=1
		done
		if [ $count -eq 1 ]; then
			# only one suitable place found, try to find an image there
			mp="${path%%:*}"
			squashfsimage="$(find_image_file "$mp")"
			rc=$?
			if [ $rc -eq 1 ]; then
				notfound=1
				rc=0
			fi
			echo -ne "\n" 1>&2
		else
			notfound=1
		fi
		if [ $notfound -eq 1 ]; then
			# no file found yet, let the user specify a new one or abort the execution
			echo "$(get_localized $lang 156 $firmwarestoragename $rootfsname)" 1>&2
			while [ 1 -eq 1 ]; do
				if [ $count -gt 1 ]; then
					# more than one possible place to store the pattern
					pathinput=0
					selection=""
					while [ 1 -eq 1 ]; do
						echo -e "\n$(get_localized $lang 157)\n" 1>&2
						index=0
						answers=""
						for mp in $path; do
							space="${mp##*:}"
							pathto="${mp%%:*}"
							letter=${letters:$index:1}
							device=$($bb sed -n -e "s|^\([^ ]*\) $pathto .*|\1|p" /proc/mounts)
							filesystem=$($bb sed -n -e "s|^[^ ]* $pathto \([^ ]*\) .*|\1|p" /proc/mounts)
							[ $filesystem == fuseblk ] && filesystem="NTFS_via_fuse"
							let index+=1
							line="$(get_localized $lang 158 "$letter" "$device" "$filesystem" "$pathto")"
							echo -e "$line" 1>&2
							answers=$answers$letter
						done
						echo -e "$(get_localized $lang 159)" 1>&2
						echo -e "$(get_localized $lang 160)" 1>&2
						echo -ne "\n$(get_localized $lang 161) " 1>&2
						while read -n 10 -s -t 1; do :; done
						read -n 1 -s selection
						case "$selection" in
							[qQ])
								echo -e "$selection$(get_localized $lang 131)" 1>&2
								return 1
								;;
							[pP])
								pathinput=1
								breaknow=1
								rc=1
								;;
							*)
								if [ ${#selection} -gt 0 ]; then
									if [ $(expr index $selection $answers$(uppercase $answers)) -gt 0 ]; then
										breaknow=1
									fi
								else
									echo -e "$selection\n$(get_localized $lang 127)" 1>&2
									continue
								fi
								;;
						esac
						if [ x"$selection" == x"p" ]; then
							echo -ne "$selection\n$msgtext_normal" 1>&2
						else
							echo -ne "$selection\n\n$msgtext_normal" 1>&2
						fi
						[ $breaknow -eq 1 ] && break
					done
				else
					selection=a
					pathinput=0
				fi
				let count-=1
				if [ $pathinput -ne 1 ]; then
					# input was not 'p'
					index=0
					newpath=""
					for mp in $path; do
						letter=${letters:$index:1}
						if [ $letter == $selection -o $(uppercase $letter) == $selection ]; then
							# use that drive to find our file
							checked="${mp%%:*}"
							squashfsimage="$(find_image_file "$checked")"
							rc=$?
							if [ $rc -eq 0 ]; then
								# ok, we've found an image
								echo "$squashfsimage"
								count=0
							fi
						else
							# the probed path will be removed from the list
							newpath=""$newpath" "$mp""
						fi
						let index+=1
					done
					if [ $rc -ne 0 ]; then
						# show error message and try again without the probed path
						echo -e "$(get_localized $lang 169 "$checked")" 1>&2
						path="$newpath"
						rc=1
					fi
				fi
				# we're finished, if we've found an image or the choice was 'p' or there're no more places to search
				[ $count -eq 0 -o $pathinput -eq 1 ] && echo "" 1>&2 && break
			done
			if [ $rc -eq 1 ]; then
				while [ 1 -eq 1 ]; do
					# let the user select his own source
					echo "$(get_localized $lang 170)" 1>&2
					read pathname
					if [ x"$pathname" == xq ]; then
						echo -e "$(get_localized $lang 116)" 1>&2
						rc=1
						break
					fi
					echo -ne "$msgtext_normal" 1>&2
					if [ -f "$pathname" ]; then
						check_squashfs_image "$pathname"
						rc=$?
						if [ $rc -gt 1 ]; then
							return $rc
						else
							squashfsimage="$pathname"
						fi
						if [ $rc -eq 1 ]; then
							squashfsimage="$(check_firmware_image "$pathname")"
							rc=$?
						fi
						if [ $rc -eq 0 ]; then
							check_squashfs_file_version "$squashfsimage"
							rc=$?
							if [ $rc -eq 0 ]; then
								echo "$squashfsimage"
								break
							fi
						fi
					else
						echo "$(get_localized $lang 171 "$pathname")" 1>&2
					fi
				done
			fi
		else
			# pattern image found
			echo "$squashfsimage"
			debug "get_input_image_path: $squashfsimage"
		fi
	else
		echo -e "$(get_localized $lang 58)" 1>&2
		rc=58
	fi
	debug "get_input_image_path: exiting, rc=$rc"
	return $rc
}
#
# check prerequisites
# - check hardware revision
# - find 'switch' variable at environment
# - find kernel partitions
# - compare kernel hashes
# - find filesystem partitions
#
check_prerequisites()
{
	local rc=0 nxt k1 k2 hwrev f1 f2 path
	echo -ne "$msgtext_clearscreen" 1>&2
	debug "check_prerequisites: starting checks"
	# get hardware revision
	progress 1 98
	hwrev="$(get_hardware_revision)"
	debug "check_prerequisites: hwrev=$hwrev"
	if [ ${#hwrev} -gt 0 ]; then
		progress 3 96
		# check hardware revision
		progress 1 99
		if check_hardware_revision "$hwrev"; then
			debug "check_prerequisites: unsupported hardware revision"
			progress 3 97
			msg="$(get_localized $lang 36 $hwrev)"
			echo -e "$msg\n" 1>&2
			rc=36
		else
			debug "check_prerequisites: supported hardware revision"
			progress 3 96
			# find boot time system selection switch
			progress 1 100
			nxt=$(get_system_switch)
			if [ ${#nxt} -eq 0 ]; then
				debug "check_prerequisites: system switch value missing"
				progress 3 97
				msg="$(get_localized $lang 35 $fsvarname)"
				echo -e "$msg\n" 1>&2
				rc=35
			else
				debug "check_prerequisites: system switch value is $nxt"
  				progress 3 96
				# check, if system is modified already
				progress 1 101
				if is_switched; then
					if [ $undo_switch -eq 1 ]; then
						progress 3 96
						return 0
					else
						progress 3 97
						msg="$(get_localized $lang 37)"
						echo -e "$msg\n" 1>&2
						rc=37
					fi
				else
					if [ $undo_switch -eq 1 ]; then
						progress 3 97
						return 1
					fi
					progress 3 96
					# find kernel MTD
					progress 1 102
					k1=$(get_mtd_by_name $kernelname)
					if [ ${#k1} -eq 0 ]; then
						debug "check_prerequisites: no kernel device found"
						progress 3 97
						msg="$(get_localized $lang 33 $kernelname)"
						echo -e "$msg\n" 1>&2
						rc=33
					else
						debug "check_prerequisites: kernel device is /dev/$mtdblockname$k1"
						progress 3 96
						# find alternative kernel MTD
						progress 1 103
						k2=$(get_mtd_by_name $reservedprefix$kernelname)
						if [ ${#k2} -eq 0 ]; then
							debug "check_prerequisites: no alternative kernel device found"
							progress 3 97
							msg="$(get_localized $lang 34 $reservedprefix$kernelname)"
							echo -e "$msg\n" 1>&2
							rc=34
						else
							debug "check_prerequisites: alternative kernel device is /dev/$mtdblockname$k2"
							progress 3 96
							progress 1 104
							if [ $noversioncheck -eq 1 ]; then
								progress 3 95
								rc=0
							else
								# compare kernel versions
								msg="$(check_kernels $k1 $k2)"
								rc=$?
								if [ $rc -eq 0 ]; then
									progress 3 96
								fi
							fi
							if [ $rc -eq 0 ]; then
								# find filesystem MTD
								progress 1 105
								f1=$(get_mtd_by_name $filesystemname)
								if [ ${#f1} -eq 0 ]; then
									debug "check_prerequisites: no filesystem device found"
									progress 3 97
									msg="$(get_localized $lang 48 $filesystemname)"
									echo -e "$msg\n" 1>&2
									rc=48
								else
									debug "check_prerequisites: filesystem device is /dev/$mtdblockname$f1"
									progress 3 96
									# find alternative filesystem MTD
									progress 1 106
									f2=$(get_mtd_by_name $reservedprefix$filesystemname)
									if [ ${#f2} -eq 0 ]; then
										debug "check_prerequisites: no alternative filesystem device found"
										progress 3 97
										msg="$(get_localized $lang 49 $reservedprefix$filesystemname)"
										echo -e "$msg\n" 1>&2
										rc=49
									else
										debug "check_prerequisites: alternative filesystem device is /dev/$mtdblockname$f2"
										progress 3 96
										# find enough free local space to unpack the squashfs image
										progress 1 119
										[ $INCLUDE_NAND -eq 1 ] && local_nand="withnand" || local_nand="nonand"
										path=$(find_free_storage_space $free_space_for_unpack $local_nand 2>/dev/null)
										rc=$?
										if [ $rc -ne 0 ]; then
											debug "check_prerequisites: not enough free space for unpacking of images"
											progress 3 97
											msg="$(get_localized $lang 51 $free_space_for_unpack)"
											echo -e "$msg\n" 1>&2
											rc=51
										else
											progress 3 96
											if [ "$CHECK_TMPFS_SPACE" = "1" ]; then
												# check free space at tmpfs
												progress 1 117
												check_free_tmpfs $free_space_at_tmpfs $warning_space_at_tmpfs
												rc=$?
												if [ $rc -gt 1 ]; then
													debug "check_prerequisites: not enough free space found at tmpfs, memory pressure"
													progress 3 97
													msg="$(get_localized $lang 50)"
													echo -e "$msg\n" 1>&2
													rc=50
												else
													if [ $rc -eq 1 ]; then
														progress 3 118
													else
														progress 3 96
													fi
												fi
											fi
										fi
									fi
								fi
							else
								progress 3 97
								msg="$(get_localized $lang 32)"
								echo -e "$msg\n" 1>&2
							fi
						fi
					fi
				fi
			fi
		fi
	else
		debug "check_prerequisites: unable to find hardware revision"
		progress 3 97
		msg="$(get_localized $lang 47 $hwrevname)" 1>&2
		echo -e "$msg\n" 1>&2
		rc=47
	fi
	debug "check_prerequisites: exiting, rc=$rc"
	return $rc
}
#
# check available swap space
#
# $1 - needed swap space in MB
#
check_swap_space()
{
	local required="$1" msg space_required space_available=0 rc device devtype size more
	msg="$(get_localized $lang 224)" 1>&2
	echo -n -e "$msg" 1>&2
	if [ "$MODFS_WITHOUT_SWAP" = "i_am_sure" ]; then
		progress 3 95
		debug "check_swap_space: skip check due to set environment variable"
		return 0
	fi
	debug "check_swap_space: requested space=$required MB"
	space_required=$(( required * 1024 * 1024 ))
	while read device devtype size more; do
		[ "$devtype" = "file" ] && space_available=$(( space_available + ( size * 1024 ) ))
		[ "$devtype" = "partition" ] && space_available=$(( space_available + ( size * 1024 ) ))
	done </proc/swaps
	if [ $space_available -eq 0 ]; then
		progress 3 97
		msg="$(get_localized $lang 225)" 1>&2
		echo -e "$msg\n" 1>&2
		rc=1
	elif [ $space_available -lt $space_required ]; then
		progress 3 97
		msg="$(get_localized $lang 226 $required $(( space_available / 1024 / 1024 )))" 1>&2
		echo -e "$msg\n" 1>&2
		rc=1
	else
		progress 3 96
		rc=0
	fi
	debug "check_swap_space: finished, rc=$rc, space available=$space_available"
	return $rc
}
#
# get source selection
#
get_source()
{
	local source selection
	debug "get_source: starting selection"
	while [ 1 -eq 1 ]; do
		if [ $noversioncheck -eq 0 ]; then
			echo -e "\n$(get_localized $lang 110)" 1>&2
			echo -e "$(get_localized $lang 111)" 1>&2
			echo -e "$(get_localized $lang 112)" 1>&2
		else
			echo -e "\n$(get_localized $lang 184)" 1>&2
			echo -e "$(get_localized $lang 185)" 1>&2
		fi
		echo -e "$(get_localized $lang 113)" 1>&2
		echo -ne "\n$(get_localized $lang 114) " 1>&2
		while read -n 10 -s -t 1; do :; done
		read -n 1 -s selection
		if [ $noversioncheck -eq 0 ]; then
			case "$selection" in
				[aA])
					source=running
					;;
				[bB])
					source=download
					;;
				[cC])
					source=file
					;;
				[qQ])
					source=quit
					;;
				*)
					echo -e "$selection\n$(get_localized $lang 115)" 1>&2
					continue
					;;
			esac
			break
		else
			case "$selection" in
				[aA])
					source=download_update
					;;
				[bB])
					source=file_update
					;;
				[qQ])
					source=quit
					;;
				*)
					echo -e "$selection\n$(get_localized $lang 115)" 1>&2
					continue
					;;
			esac
			break
		fi
	done
	echo -ne "$selection\n$msgtext_normal" 1>&2
	echo $source
	debug "get_source: $source"
}
#
# get working directory decision from user
#
get_working_directory()
{
	local dir needed="$1" places="$2"
	if ! [ -z "$MODFS_WORKING_DIR" ]; then
		debug "get_working_directory: using preselection, MODFS_WORKING_DIR=$MODFS_WORKING_DIR"
		echo "$MODFS_WORKING_DIR"
		return 0
	fi
	dir="$(find_free_space $needed "$places")"
	if [ $? -ne 0 ]; then
		return 52
	fi
	echo "$dir"
	debug "get_working_directory: $dir"
	return 0
}
#
# compare firmware versions
#
# 0   - left is newer
# 1   - left is equal
# 2   - left is older
# 4   - different models
# 128 - invalid left or right version
#
compare_versions()
{
	local left="$1" right="$2" left_model left_major left_minor right_model right_major right_minor
	eval "$(echo $left | $bb sed -n -e 's/\([0-9]\{1,3\}\)\.\([0-9]\{2\}\)\.\([0-9]\{2\}\)\(-[0-9]*\)\?/left_model=\1 left_major=\2 left_minor=\3 left_sub=\4/p')"
	eval "$(echo $right | $bb sed -n -e 's/\([0-9]\{1,3\}\)\.\([0-9]\{2\}\)\.\([0-9]\{2\}\)\(-[0-9]*\)\?/right_model=\1 right_major=\2 right_minor=\3 right_sub=\4/p')"
	debug "compare_version: left=$left, right=$right"
	[ ${#left_model} -eq 0 -o ${#left_major} -eq 0 -o ${#left_minor} -eq 0 -o ${#right_model} -eq 0 -o ${#right_major} -eq 0 -o ${#right_minor} -eq 0 ] && return 128 # wrong input data
	[ $left_model -ne $right_model ] && return 4 # different version
	[ $left_major -gt $right_major ] && return 0 # newer
	if [ $left_major -eq $right_major ]; then
		[ $left_minor -gt $right_minor ] && return 0 # newer
		if [ $left_minor -eq $right_minor ]; then
			if [ ${#left_sub} -gt 0 -a ${#right_sub} -gt 0 ]; then
				left_sub="${left_sub:1}"
				right_sub="${right_sub:1}"
				left_sub=$(( "${left_sub//[^0-9]}" )) # remove any suffix like "M"
				right_sub=$(( "${right_sub//[^0-9]}" ))
				[ $left_sub -gt $right_sub ] && return 0 # newer
				[ $left_sub -eq $right_sub ] && return 1
				return 2
			else
				return 1
			fi
		else
			return 2
		fi
	fi
	return 1
}
#
# retrieve newer or current version number and URL from manufacturer
#
get_version_from_manufacturer()
{
	local target="${1:-newer}" rc=0 msg nf err res opt NewVersion DownloadURL curr comp
	debug "get_version_from_manufacturer: target=$target"
	[ $target == current ] && opt="-c"
	curr="$(get_system_version)"
	[ $target == current ] && progress 1 207 "$curr" || progress 1 188
	res="$($shl $scriptwrapper $(scriptdir)/juis_check -n -l -p $opt 2>/dev/null)"
	rc=$?
	if [ $rc -ne 0 ]; then
		progress 3 97
		debug "get_version_from_manufacturer: error $rc returned from juis_check"
		if [ $rc -eq 2 ]; then
			if [ $target == current ]; then
				echo "$(get_localized $lang 208 $curr)" 1>&2
				rc=208
			else
				echo "$(get_localized $lang 190 $curr)" 1>&2
				rc=190
			fi
		else
			if [ $target == current ]; then
				echo "$(get_localized $lang 209 $curr)" 1>&2
				rc=209
			else
				echo "$(get_localized $lang 187)" 1>&2
				rc=187
			fi
		fi
	else
		eval "$res"
		if [ $target == current ]; then
			debug "get_version_from_manufacturer: found current version $NewVersion, URL=$URL"
			compare_versions "$NewVersion" "$(get_system_version)"
			comp=$?
			if [ $comp -eq 1 ]; then
				progress 3 96
				rc=0
			else
				progress 3 97
				echo "$(get_localized $lang 208 $curr)" 1>&2
				rc=208
			fi
		else
			progress 3 96
			ShowVersion=$(printf "%s" "$NewVersion" | sed -e "y/ /_/")
			echo "$(get_localized $lang 189 "$ShowVersion")" 1>&2
			debug "get_version_from_manufacturer: found new version $NewVersion, URL=$URL"
		fi
	fi
	debug "get_version_from_manufacturer: exiting, rc=$rc"
	[ $rc -eq 0 ] && printf "DownloadURL=%s\nNewVersion=\"%s\"\n" "$URL" "$NewVersion"
	return $rc
}
#
# remove temporary directories before exiting
#
cleanup()
{
	debug "cleanup: running cleanup from file $tempfilelist"
	[ $MODFS_DEBUG -eq 1 ] && ($bb cat $tempfilelist 2>/dev/null | $debugoutput)
	. $tempfilelist 2>/dev/null
	$bb rm $tempfilelist 2>/dev/null
}
#
# show a spinner as progress indicator at stderr
# - each line output to stdout/stderr leads to a new position of the spinner
# $1 - working directory to build the needed FIFO
#
spinner()
(
	run_spinner()
	(
		i=1
		IFS='' set -- '|' '/' '-' '\'
		while read l; do
			eval c="\$$i"
			printf "\x1B[1D$c" 1>&2
			i=$(( ( i % 4 ) + 1 ))
		done
	)

	dir="$1"
	shift
	debug "run_spinner: dir=$dir, command=$@"
	printf "  " 1>&2
	spin_from="$dir/$($bb date +%s)_$$"
	$bb mkfifo "$spin_from"
	run_spinner <"$spin_from" &
	spinpid=$!
	stderr="$dir/$($bb date +%s)_$$_stderr"
	"$@" >"$spin_from" 2>"$stderr"
	rc=$?
	wait $spinpid
	$bb rm "$spin_from" 2>/dev/null
	printf "\x1B[2D" 1>&2
	debug "run_spinner: exiting, rc=$rc"
	if [ $rc -ne 0 ]; then
		debug "run_spinner: stderr output follows"
		$debugoutput <"$stderr"
	fi
	rm -f "$stderr" 2>/dev/null
	return $rc
)
#
# init ring buffer file
#
init_ringbuffer_file()
{
	local file="$1" size=$2 value offset newformat=0 mask
	$debugtest -? 2>&1 | grep -q -- '-m[ \t]*- print' && newformat=1
	$bb dd if=/dev/zero of=$file bs=1024 count=$size 2>/dev/null
	# signature
	printf "\371\023\146\216" | $bb dd of=$file bs=4 count=1 conv=notrunc seek=0 2>/dev/null
	if [ $newformat -eq 0 ]; then
		value=$(( size * 1024 - 1 ))
		# first entry
		printf "\024" | $bb dd of=$file bs=1 count=1 conv=notrunc seek=7 2>/dev/null
		# last entry
		printf "\024" | $bb dd of=$file bs=1 count=1 conv=notrunc seek=11 2>/dev/null
		# next entry
		printf "\024" | $bb dd of=$file bs=1 count=1 conv=notrunc seek=15 2>/dev/null
		offset=19
	else
		value=$(( size * 1024 ))
		offset=15
	fi
	while [ $value -gt 0 ]; do
		mask=$(printf "\\%03o" $(( value % 256 )))
		printf "$mask" | $bb dd of=$file bs=1 count=1 conv=notrunc seek=$offset 2>/dev/null
		offset=$(( offset - 1 ))
		value=$(( value >> 8 ))
	done
	printf "with a %s KB buffer%s" "$size" "$([ $newformat -eq 1 ] && printf " (new format)")" 1>&2
}
#
# execution starts here, if called as shell script
#
# prepare script environment
scriptcalledbyname="$0"
scriptfile="$scriptcalledbyname"
while [ -L "$scriptfile" ]; do scriptfile="$($bb readlink "$scriptfile")"; done
scriptfile="$($bb realpath $scriptfile)"
scriptpath="${scriptfile%/*}"
scriptname="${scriptfile##*/}"
# switch to our own version of Busybox
bb="$(bindir)/busybox"
shl="$bb sh"
if ! [ "$MODFS_RUN_SHELL" = "1" ]; then
	tgt="$(readlink "$(bindir)")"
	tgtsuf="${tgt%%_*}"
	if ! [ "$tgtsuf" = "$tgt" ]; then
		pd="$bindirname/${tgtsuf}_$(uname -r)"
		[ -d "$pd" ] && tgtexists=1 || tgtexists=0
		if [ $tgtexists -eq 1 ] && ! [ "$bindirname/$tgt" = "$pd" ]; then
			( cd "$scriptpath/$bindirname"; ln -s -f -n -T "${pd##*/}" $HWRevision )
			printf "${msgtext_bold}Information: Changed binaries directory link to versions for kernel '%s'.${msgtext_normal}\n" "$(uname -r)" 1>&2
		else
			if [ $tgtexists -eq 0 ]; then
				printf "${msgtext_warning}Warning:${msgtext_normal}${msgtext_bold} No binaries directory for kernel version '%s' found.${msgtext_normal}\n" "$(uname -r)" 1>&2
			fi
		fi
	fi
	mkdir -p /var/run/modfs
	ln -s -f $bb /var/run/modfs/sh
	oldpath="$PATH"
	export PATH=$(bindir)
	export MODFS_RUN_SHELL=1
	export SHELL=/var/run/modfs/sh
	echo "respawn script with custom BusyBox shell, SHLVL=$SHLVL" 1>&2
	if [ x"$MODFS_DEBUG_SHELL" == x"1" ]; then
		[ -f "$modfsshelldebug" ] && rm "$modfsshelldebug" 2>/dev/null
		export MODFS_DEBUG_SHELL_FILE="$modfsshelldebug"
	fi
	echo "$shl $0 $*" 1>&2
	$shl $0 $*
	rc=$?
	export PATH="$oldpath"
	rm -r /var/run/modfs 2>/dev/null
	exit $rc
fi
#
# check debug settings and initialize ring buffer, if necessary
#
ringbufferfile=$(eval echo $ringbufferfile)
debugoutput=$(eval echo $debugoutput)
if ! [ "$MODFS_DEBUG" = "0" ]; then
	echo -n "Using debug mode " 1>&2
	DEBUG_BUFSIZE=${MODFS_BUFSIZE:-64}
	debugfile="$(eval echo $ringbufferfile)"
	$bb rm $debugfile 2>/dev/null
	init_ringbuffer_file $debugfile $DEBUG_BUFSIZE
	echo -e "\n" 1>&2
	MODFS_DEBUG=1
fi
#
# include / exclude NAS NAND flash as working directory
#
INCLUDE_NAND=${INCLUDE_NAND:-0}
! [ "$INCLUDE_NAND" = "0" ] && ! [ "$INCLUDE_NAND" = "1" ] && INCLUDE_NAND=0
[ $INCLUDE_NAND -eq 0 ] && nand="nonand" || nand="nand"
#
# FRITZ!Box language environment setting
#
lang=$Language
if [ ! -r $(localedir)/$lang ]; then
	echo "The localized messages file for '$lang' was not found, probing fallback to 'en'." 1>&2
	lang=en
fi
debug "modfs: starting modfs script version $modfs_version"
debug "modfs: script=$scriptcalledbyname"
if [ ! -r $(localedir)/$lang ]; then
	echo "The localized messages file for '$lang' does not exist." 1>&2
	debug "modfs: missing localization file for $lang"
	exit 66
fi
debug "modfs: using language $lang"
#
# initialize variables (unnecessary, only for the sake of good order and to get numeric instead of character values as needed)
#
base_directory="$(pwd)"
export MODFS_DIR="$base_directory"
working_directory=""
unpack_directory=""
loopback_host=""
baseimage=""
loopback_used=0
squashfs_blocksize=0
squashfs_endianess=0
rc=0
debug "modfs: PWD=$base_directory"
debug "modfs: PATH=$PATH"
debug "modfs: SHELL=$SHELL"
debug "modfs: SHLVL=$SHLVL"
debug "modfs: BusyBox: $(busybox | sed -n -e '1p')"
debug "modfs: Filesystems mounted"
$bb cat /proc/mounts | $debugoutput
debug "modfs: Free space"
$bb df -h | $debugoutput
debug "modfs: Swap space"
$bb cat /proc/swaps | $debugoutput
debug "modfs: Loop devices"
$bb losetup -a | $debugoutput
if [ $? -ne 0 ]; then
	for l in /sys/devices/virtual/block/loop*; do echo /dev/${l##*/}: $(cat $l/loop/offset) $(cat $l/loop/backing_file) 2>/dev/null; done | $debugoutput
fi
#
# we'll store an unlink command for all temporary directories and files here and remove it, if the target is deleted elsewhere
#
tempfilelist="$tmpfsbasedir/$$_filelist_$($bb date +%s)"
$bb touch $tempfilelist
debug "modfs: using temporary file list from $tempfilelist"
trap 'cleanup' EXIT HUP INT
debug "modfs: cleanup trap set"
#
# check for 'undo' request, which is the only argument, what we expect
#
debug "modfs: invoked with: $@"
if [ "$1" = "undo" ]; then
	undo_switch=1
	check_prerequisites
	rc=$?
	if [ $rc -eq 0 ]; then
		switchback=$(ask_yes_or_no n "$(get_localized $lang 194)")
		if [ $switchback == Y ]; then
			progress 1 152
			switch_system_to current
			progress 3 96
			echo -e "$(get_localized $lang 154)" 1>&2
			debug "modfs: undo finished, switched back to running system"
			exit 0
		else
			echo -e "$(get_localized $lang 153)" 1>&2
			debug "modfs: undo finished, abandoned switching back to running system"
			exit 1
		fi
	else
		echo -e "$(get_localized $lang 151)" 1>&2
		debug "modfs: undo finished, error $rc checking prerequisites"
		exit 1
	fi
	exit $rc
else
	undo_switch=0
	noversioncheck=0
	update_file_provided=0
	create_image_only=0
	install_image_only=0
	install_no_wrapper=0
	install_no_kernel=0
	no_sigcheck=0
	case $1 in
		update)
			noversioncheck=1
			if ! [ -z "$2" ]; then
				firmware_update_file="$2"
				update_file_provided=1
				if ! [ -z "$3" ]; then
					create_image_only=1
					target_image_name="$3"
				fi
			fi
			;;

		install|installfs|installroot)
			update_file_provided=1
			noversioncheck=1
			install_image_only=1
			if [ -z "$2" ]; then
				echo "Missing name of image file to be installed." 1>&2
				exit 1
			else
				firmware_update_file="$2"
			fi
			if [ "$1" = "installfs" ] || [ "$1" = "installroot" ]; then
				install_no_kernel=1
			fi
			if [ "$1" = "installroot" ]; then
				install_no_wrapper=1
			fi
			;;

		installimage)
			update_file_provided=1
			noversioncheck=1
			install_image_only=1
			if [ -z "$2" ]; then
				echo "Missing name of image file to be installed." 1>&2
				exit 1
			else
				firmware_update_file="$2"
			fi
			install_no_kernel=0
			install_no_wrapper=1
			;;

		'')
			: # no parameter specified
			;;

		*)
			echo "Unknown parameter '$1'." 1>&2
			exit 1
	esac
	debug "modfs: noversioncheck=$noversioncheck, update_file_provided=$update_file_provided"
	[ $update_file_provided -eq 1 ] && debug "modfs: firmware_update_file=$firmware_update_file"
	[ $create_image_only -eq 1 ] && debug "modfs: create_image_only=1, target_image_name=$target_image_name"
	[ $install_image_only -eq 1 ] && debug "modfs: install_image_only=1, firmware_update_file=$firmware_update_file, install_no_kernel=$install_no_kernel, install_no_wrapper=$install_no_wrapper"
	if [ x"$NOVERIFY" == x"1" ]; then
		no_sigcheck=1
		debug "modfs: no_sigcheck=1 requested"
	fi
	scriptwrapper="$(scriptdir)/$scriptwrapper"
fi
#
# check prerequisites first, any further action depends on them
#
check_prerequisites
prerc=$?
if [ $prerc -eq 32 ]; then
	copypart=$(ask_yes_or_no n "$(get_localized $lang 192)")
	if [ $copypart == Y ]; then
		copy_running_system
		rc=$?
		if [ $rc -ne 0 ]; then
			echo -e "$(get_localized $lang $rc)" 1>&2
		else
			echo -e "$(get_localized $lang 183)" 1>&2
			prerc=0
		fi
	elif [ "$copypart" = "C" ]; then
		exit 1
	else
		debug "modfs: continuing with a different kernel version"
		prerc=0
	fi
fi
[ $prerc -ne 0 ] && exit $prerc
check_swap_space $swap_space_needed
prerc=$?
[ $prerc -ne 0 ] && exit $prerc
echo -e "$(get_localized $lang 107 "$(get_system_version)")\n" 1>&2
if [ $install_image_only -eq 1 ]; then
	source="file_update"
else
	if [ $noversioncheck -eq 1 ]; then
		if [ $update_file_provided -eq 0 ]; then
			echo -e "$(get_localized $lang 186)" 1>&2
		else
			echo -e "$(get_localized $lang 201)" 1>&2
		fi
	fi
	if [ $noversioncheck -eq 1 ]; then
		if [ $update_file_provided -eq 1 ]; then
			source="file_update"
		else
			source="download_update"
		fi
	else
		echo -e "$(get_localized $lang 108)" 1>&2
		echo -e "$(get_localized $lang 109)" 1>&2
		source=$(get_source)
	fi
fi
debug "modfs: source=$source"
if [ $source == quit ]; then
	echo -e "$(get_localized $lang 116)" 1>&2
	exit 0
else
	echo -ne "\n" 1>&2
fi
case $source in
	running)
		# nothing to do prior to unpacking
		echo -e "$(get_localized $lang 120)\n" 1>&2
		baseimage="$wrapperdir/$rootfsname"
		debug "modfs: baseimage=$baseimage"
		debug "modfs: running system selected"
		;;
	download)
		working_directory="$(get_working_directory $download_space_needed "tmpfs $nand storage")"
		rc=$?
		if [ $rc -ne 0 ]; then
			echo -e "$(get_localized $lang $rc)" 1>&2
			debug "modfs: unable to get working directory"
			exit $rc
		fi
		debug "modfs: working directory=$working_directory"
		version="$(get_system_version)"
		download_directory="$working_directory/$($bb date +%s)"
		$bb mkdir -p "$download_directory"
		echo "$bb rm -r $download_directory" >>$tempfilelist
		debug "modfs: download directory=$download_directory"
		download_version="$(get_version_from_manufacturer current)"
		rc=$?
		if [ $rc -eq 0 ]; then
			eval "$download_version"
			progress 1 121 "$version"
			download_firmware "$download_directory/$firmwarestoragename" "$DownloadURL"
			rc=$?
			if [ $rc -ne 0 ]; then
				if [ $rc -eq 42 ]; then
					progress 3 97
					echo "$(get_localized $lang 42)" 1>&2
				else
					if [ $rc -eq 43 ]; then
						progress 3 97
						echo "$(get_localized $lang 43)" 1>&2
					fi
				fi
				exit $rc
			else
				progress 3 96
				if [ $no_sigcheck -ne 1 ]; then
					try_to_check_integrity "$download_directory/$firmwarestoragename"
					rc=$?
					if [ $rc -ne 0 ]; then
						exit $rc
					fi
				fi
				working_directory="$(get_working_directory $extract_space_needed "tmpfs $nand storage")"
				rc=$?
				if [ $rc -ne 0 ]; then
					echo -e "$(get_localized $lang $rc)" 1>&2
					exit $rc
				fi
				image_directory="$working_directory/$($bb date +%s)"
				$bb mkdir -p "$image_directory"
				echo "$bb rm -r $image_directory" >>$tempfilelist
				progress 1 132
				extract_rootfs_from_firmware "$download_directory/$firmwarestoragename" "$image_directory/$rootfsname"
				rc=$?
				if [ $rc -ne 0 ]; then
					progress 3 97
					echo -e "$(get_localized $lang $rc)" 1>&2
					exit $rc
				else
					progress 3 96
					baseimage="$image_directory/$rootfsname"
					progress 1 133
					remove_directory "$download_directory"
					progress 3 96
					copybase=$(ask_yes_or_no n "$(get_localized $lang 193)")
					if [ $copybase == Y ]; then
						target=""
						if [ $(is_tmpfs $image_directory) -eq 1 ]; then
							targetdir="$(get_persistent_path $(( $($bb stat -c %s "$baseimage") + 4096 )) )"
							rc=$?
							if [ $rc -eq 0 ]; then
								target=$targetdir/$rootfsname
							fi
						else
							target="$working_directory/$rootfsname"
						fi
						progress 1 134
						[ $rc -eq 0 ] && $bb mv "$image_directory/$rootfsname" "$target"
						rc=$?
						if [ $rc -ne 0 ]; then
							progress 3 97
							if [ ${#target} -gt 0 ]; then
								echo -e "$(get_localized $lang 53)" 1>&2
								exit 53
							fi
						else
							progress 3 96
							echo -e "$(get_localized $lang 135 "$target")" 1>&2
							baseimage="$target"
							remove_directory "$image_directory"
						fi
					elif [ "$copybase" = "C" ]; then
						exit 1
					fi
				fi
				debug "modfs: baseimage=$baseimage"
				debug "modfs: download done"
			fi
		fi
		;;
	file)
		baseimage="$(get_input_image_path)"
		rc=$?
		if [ $rc -gt 1 ]; then
			echo -e "$(get_localized $lang $rc)" 1>&2
			exit $rc
		fi
		# no file name selected means abort execution, an error message was already displayed
		[ ${#baseimage} -eq 0 ] && rc=1
		debug "modfs: baseimage=$baseimage"
		debug "modfs: file selection done"
		;;
	download_update)
		download_version="$(get_version_from_manufacturer)"
		rc=$?
		if [ $rc -eq 0 ]; then
			eval "$download_version"
			working_directory="$(get_working_directory $download_space_needed "tmpfs $nand storage")"
			rc=$?
			if [ $rc -ne 0 ]; then
				debug "modfs: unable to get working directory"
				echo -e "$(get_localized $lang $rc)" 1>&2
				exit $rc
			fi
			debug "modfs: working directory=$working_directory"
			ShowVersion=$(printf "%s" "$NewVersion" | sed -e "y/ /_/")
			progress 1 121 "$ShowVersion"
			download_directory="$working_directory/$($bb date +%s)"
			$bb mkdir -p "$download_directory"
			echo "$bb rm -r $download_directory" >>$tempfilelist
			debug "modfs: download directory=$download_directory"
			download_firmware "$download_directory/$firmwarestoragename" "$DownloadURL"
			rc=$?
			if [ $rc -ne 0 ]; then
				if [ $rc -eq 42 ]; then
					progress 3 97
					echo "$(get_localized $lang 42)" 1>&2
				else
					if [ $rc -eq 43 ]; then
						progress 3 97
						echo "$(get_localized $lang 43)" 1>&2
					fi
				fi
				exit $rc
			else
				progress 3 96
				if [ $no_sigcheck -ne 1 ]; then
					try_to_check_integrity "$download_directory/$firmwarestoragename"
					rc=$?
					if [ $rc -ne 0 ]; then
						exit $rc
					fi
				fi
				working_directory="$(get_working_directory $fullimage_space_needed "tmpfs $nand storage")"
				rc=$?
				if [ $rc -ne 0 ]; then
					echo -e "$(get_localized $lang $rc)" 1>&2
					exit $rc
				fi
				image_directory="$working_directory/$($bb date +%s)"
				$bb mkdir -p "$image_directory"
				echo "$bb rm -r $image_directory" >>$tempfilelist
				progress 1 195
				extract_kernel "$download_directory/$firmwarestoragename" "$image_directory/$kernelfilename"
				rc=$?
				if [ $rc -ne 0 ]; then
					progress 3 97
					echo -e "$(get_localized $lang $rc)" 1>&2
					exit $rc
				else
					progress 3 96
					progress 1 63
					extract_filesystem "$download_directory/$firmwarestoragename" "$image_directory/$outerimagename"
					rc=$?
					if [ $rc -ne 0 ]; then
						progress 3 97
						echo -e "$(get_localized $lang $rc)" 1>&2
						exit $rc
					else
						progress 3 96
						progress 1 64
						extract_rootfs_from_outer_filesystem "$image_directory/$outerimagename" "$image_directory/$rootfsname"
						rc=$?
						if [ $rc -ne 0 ]; then
							progress 3 97
							echo -e "$(get_localized $lang $rc)" 1>&2
							exit $rc
						else
							progress 3 96
							baseimage="$image_directory/$rootfsname"
							newkernelimage="$image_directory/$kernelfilename"
							outerimage="$image_directory/$outerimagename"
							progress 1 133
							remove_directory "$download_directory"
							progress 3 96
						fi
					fi
				fi
			fi
			debug "modfs: baseimage=$baseimage"
			debug "modfs: newkernelimage=$newkernelimage"
			debug "modfs: outerimage=$outerimage"
			debug "modfs: download_update selection done"
		fi
		;;
	file_update)
		if [ $update_file_provided -eq 0 ]; then
			baseimage="$(get_input_image_path)"
			rc=$?
			if [ $rc -gt 1 ]; then
				echo -e "$(get_localized $lang $rc)" 1>&2
				exit $rc
			fi
			# no file name selected means abort execution, an error message was already displayed
			[ ${#baseimage} -eq 0 ] && rc=1
			debug "modfs: file_update mode, file selection canceled"
		else
			debug "modfs: firmware update file=$firmware_update_file"
			if ! [ -r "$firmware_update_file" ]; then
				progress 3 200 "$firmware_update_file"
				rc=200
			else
				firmware_update_file="$($bb realpath $firmware_update_file)"
				progress 3 199 "$firmware_update_file"
				rc=0
			fi
		fi
		if [ $rc -eq 0 ]; then
			working_directory="$(get_working_directory $fullimage_space_needed "tmpfs $nand storage")"
			rc=$?
			if [ $rc -ne 0 ]; then
				echo -e "$(get_localized $lang $rc)" 1>&2
				debug "modfs: unable to get working directory"
				exit $rc
			fi
			debug "modfs: working directory=$working_directory"
			image_directory="$working_directory/$($bb date +%s)"
			$bb mkdir -p "$image_directory"
			echo "$bb rm -r $image_directory" >>$tempfilelist
			debug "modfs: image directory=$image_directory"
			if [ $no_sigcheck -ne 1 ]; then
				try_to_check_integrity "$firmware_update_file"
				rc=$?
				if [ $rc -ne 0 ]; then
					exit $rc
				fi
			fi
			progress 1 195
			extract_kernel "$firmware_update_file" "$image_directory/$kernelfilename"
			rc=$?
			if [ $rc -ne 0 ]; then
				progress 3 97
				echo -e "$(get_localized $lang $rc)" 1>&2
				exit $rc
			else
				progress 3 96
				progress 1 63
				extract_filesystem "$firmware_update_file" "$image_directory/$outerimagename"
				rc=$?
				if [ $rc -ne 0 ]; then
					progress 3 97
					echo -e "$(get_localized $lang $rc)" 1>&2
					exit $rc
				else
					progress 3 96
					progress 1 64
					extract_rootfs_from_outer_filesystem "$image_directory/$outerimagename" "$image_directory/$rootfsname"
					rc=$?
					if [ $rc -ne 0 ]; then
						progress 3 97
						echo -e "$(get_localized $lang $rc)" 1>&2
						exit $rc
					else
						progress 3 96
						baseimage="$image_directory/$rootfsname"
						newkernelimage="$image_directory/$kernelfilename"
						outerimage="$image_directory/$outerimagename"
					fi
				fi
			fi
			debug "modfs: baseimage=$baseimage"
			debug "modfs: newkernelimage=$newkernelimage"
			debug "modfs: outerimage=$outerimage"
			debug "modfs: file_update selection done"
		fi
		;;
esac
if [ $rc -eq 0 ]; then
	debug "modfs: initialization done"
	if [ $install_image_only -eq 0 ]; then
		# find a mountpoint with enough free storage for unpacking of squashfs
		# check current working directory (if any) first
		if [ ${#working_directory} -gt 0 ]; then
			path="$(echo "$working_directory" | check_space $free_space_for_unpack)"
			if [ ${#path} -gt 0 ]; then
				# current working directory seems to be suitable
				unpack_directory="$working_directory"
			fi
		else
			# no working directory selected yet
			unpack_directory=""
		fi
		if [ ${#unpack_directory} -eq 0 ]; then
			# we need (a new) working directory with enough free space
			unpack_directory="$(get_working_directory $free_space_for_unpack_tmpfs "tmpfs")"
			rc=$?
			if [ $rc -ne 0 ]; then
				# not enough space on tmpfs, try non-volatile storage now
				unpack_directory="$(get_working_directory $free_space_for_unpack "$nand storage")"
				rc=$?
				if [ $rc -ne 0 ]; then
					echo -e "$(get_localized $lang $rc)" 1>&2
					exit $rc
				fi
			fi
		fi
		debug "modfs: unpack directory=$unpack_directory"
		if [ $rc -eq 0 ]; then
			if [ ${#unpack_directory} -eq 0 ]; then
				echo -e "$(get_localized $lang 58)" 1>&2
				rc=58
			fi
		fi
		if [ $rc -eq 0 ]; then
			# check file system at mount point - we need a native one
			fs="$($bb sed -n -e "s|^[^ \t]* $unpack_directory \(.*\) .* . .|\1|p" /proc/mounts)"
			if [ ${#fs} -eq 0 ]; then
				fs="$($bb sed -n -e "s|^[^ \t]* $(get_mountpoint $unpack_directory) \(.*\) .* . .|\1|p" /proc/mounts)"
			fi
			index_of_item $fs "$nativefilesystems" 1>/dev/null
			ind=$?
			if [ $ind -eq 1 ]; then
				debug "modfs: using loopback device with ext3 image for unpacking"
				# we'll use a loopback device to mount our ext3 image
				progress 1 140
				unpack_directory="$unpack_directory/$($bb date +%s)"
				$bb mkdir -p "$unpack_directory"
				echo "$bb rm -r $unpack_directory" >>$tempfilelist
				$bb gunzip -c "$(filesdir)/$packedpartition" >"$unpack_directory/loopback"
				rc=$?
				if [ $rc -eq 0 ]; then
					progress 3 96
					progress 1 141
					loopback_host="$unpack_directory/loopback"
					tmp="$(get_temp_dir)"
					$bb mount -o loop $loopback_host $tmp
					if [ $rc -eq 0 ]; then
						progress 3 96
						loopback_used=1
						unpack_directory="$tmp"
					else
						progress 3 97
						echo -e "$(get_localized $lang 55)" 1>&2
						rc=55
					fi
				else
					progress 3 97
					echo -e "$(get_localized $lang 54)" 1>&2
					rc=54
				fi
				debug "modfs: unpack directory=$unpack_directory"
			else
				debug "modfs: using a native filesystem for unpacking"
				loopback_used=0
				unpack_directory="$unpack_directory/$($bb date +%s)"
				$bb mkdir -p $unpack_directory
				echo "$bb rm -r $unpack_directory" >>$tempfilelist
			fi
		fi
	else
		newimage="$baseimage"
	fi
fi
if [ $rc -eq 0 -a $install_image_only -eq 0 ]; then
	# unpack squashfs root image
	progress 1 144
	spinner "$tmpdirbase" unpack_squashfs "$baseimage" "$unpack_directory"
	rc=$?
	if [ $rc -eq 0 ]; then
		progress 3 96
		squashfs_blocksize=$(get_squashfs_blocksize $baseimage)
		squashfs_endianess=$(get_squashfs_endianess $baseimage)
		sq_version=$(get_squashfs_tools_version "$baseimage")
		echo -e "$(get_localized $lang 145 "$unpack_directory/$squashfsdirname")" 1>&2
	else
		progress 3 97
		if [ $rc -eq 38 ]; then
			echo -e "$(get_localized $lang $rc "$baseimage")" 1>&2
		else
			echo -e "$(get_localized $lang $rc)" 1>&2
		fi
	fi
	debug "modfs: unpacking SquashFS image done, rc=$rc"
fi
if [ $rc -eq 0 -a $install_image_only -eq 0 ]; then
	# modify root file system
	contribs="$(contribdir)"
	files=0
	if [ -d "$contribs" ]; then
		for dir in $($bb find "$contribs" -name "$scriptdirname" -maxdepth 2 -follow -xdev -type d 2>/dev/null); do
			files=$(( files + $($bb find "$dir" -follow -xdev -type f 2>/dev/null | $bb wc -l) ))
		done
		[ $files -gt 0 ] || contribs=""
	else
		contribs=""
	fi
	modify_rootfs "$unpack_directory/$squashfsdirname" "$scriptpath/$scriptdirname" "$contribs" "$scriptdirname"
	rc=$?
	if [ $rc -lt 2 ]; then
		rc=0
		if [ "$MODFS_NO_PAUSE_ON_PACK" = "1" ]; then
			debug "wait_for_key_before_pack: pause skipped due to environment setting"
		else
			# clear input buffer first
			echo -ne "$(get_localized $lang 150 $unpack_directory/$squashfsdirname)" 1>&2
			while [ 1 -eq 1 ]; do
				while read -n 10 -s -t 1; do :; done
				if [ "$MODFS_ABORT_BEFORE_PACK" = "Q" ]; then
					abort=$MODFS_ABORT_BEFORE_PACK
				else
					stty echo 2>/dev/null
					read -n 1 abort
				fi
				if [ "$abort" = "q" ] || [ "$abort" = "Q" ]; then
					echo -e "$(get_localized $lang 155)" 1>&2
					rc=1
					break
				else
					if [ ${#abort} -eq 0 ]; then
						echo -e "$msgtext_normal" 1>&2
						break
					fi
				fi
			done
		fi
	fi
	debug "modfs: modifications done, rc=$rc"
fi
if [ $rc -eq 0 -a $install_image_only -eq 0 ]; then
	# pack new root file system
	progress 1 146
	spinner "$unpack_directory" pack_squashfs "$unpack_directory" "$unpack_directory/newroot.squashfs" $squashfs_endianess $squashfs_blocksize $sq_version
	rc=$?
	if [ $rc -eq 0 ]; then
		progress 3 96
	else
		progress 3 97
	fi
	newimage="$unpack_directory/newroot.squashfs"
	debug "modfs: packing done, rc=$rc"
	debug "modfs: new SquashFS image statistics:"
	sq_unsquashfs -stat "$unpack_directory/newroot.squashfs" 2>/dev/null | $debugoutput
fi
if [ $create_image_only -eq 1 ]; then
	if [ $rc -eq 0 ]; then
		progress 1 202 "$target_image_name"
		$bb cp -a "$unpack_directory/newroot.squashfs" "$target_image_name"
		rc=$?
		if [ $rc -eq 0 ]; then
			progress 3 96
		else
			progress 3 97
		fi
		debug "modfs: copying image file done, rc=$rc"
	fi
else
	if [ $rc -eq 0 -a $noversioncheck -eq 1 -a $install_no_wrapper -eq 0 ]; then
		# update outer file system too, it should match the expected version for the new kernel
		progress 1 196
		copy_outer_filesystem "$outerimage"
		rc=$?
		if [ $rc -eq 0 ]; then
			progress 3 96
		else
			progress 3 97
			echo -e "$(get_localized $lang $rc)" 1>&2
		fi
		debug "modfs: update outer filesystem done, rc=$rc"
	fi
	if [ $rc -eq 0 ]; then
		# copy new root file system
		progress 1 147
		copy_new_root_filesystem "$newimage"
		rc=$?
		if [ $rc -eq 0 ]; then
			progress 3 96
		else
			progress 3 97
			echo -e "$(get_localized $lang $rc)" 1>&2
		fi
		debug "modfs: copying new filesystem done, rc=$rc"
	fi
	if [ $rc -eq 0 -a $noversioncheck -eq 1 -a $install_no_kernel -eq 0 ]; then
		# update kernel partition too
		progress 1 198
		copy_kernel_image "$newkernelimage"
		rc=$?
		if [ $rc -eq 0 ]; then
			progress 3 96
		else
			progress 3 97
			echo -e "$(get_localized $lang $rc)" 1>&2
		fi
		debug "modfs: update kernel done, rc=$rc"
	fi
	if [ $rc -eq 0 ]; then
		if [ $install_image_only -eq 1 ]; then
			switch=$(ask_yes_or_no n "$(get_localized $lang 203)")
		else
			switch=Y
		fi
		if [ x$switch == xY ]; then
			# switch system start partition
			[ -x /usr/bin/gui_bootmanager ] && /usr/bin/gui_bootmanager is_locked
			[ -x /usr/bin/bootmanager ] && /usr/bin/bootmanager is_locked
			progress 1 148
			switch_system_to alternative
			rc=$?
			if [ $rc -eq 0 ]; then
				progress 3 96
				echo -e "$(get_localized $lang 149)" 1>&2
				if [ -x /usr/bin/gui_bootmanager ]; then
					$SHELL /usr/bin/gui_bootmanager clear_cache 2>&1 | $debugoutput
					debug "modfs: gui_bootmanager found, cached data cleared, trying to refresh cache files."
					$SHELL /usr/bin/gui_bootmanager get_values 2>/dev/null 1>&2
					$SHELL /usr/bin/gui_bootmanager html_display 2>/dev/null 1>&2
					$SHELL /usr/bin/gui_bootmanager debug 2>&1 | $debugoutput
					rc=0
				elif [ -x /usr/bin/bootmanager ]; then
					if [ -d "/var/run/bootmanager" ]; then
						debug "modfs: bootmanager service found"
						printf "clear_cache\n" >/var/run/bootmanager/input
						sleep 2
						cat /var/run/bootmanager/output | $debugoutput
						rc=0
					else
						$SHELL /usr/bin/bootmanager clear_cache 2>&1 | $debugoutput
						debug "modfs: bootmanager found, cached data cleared, trying to refresh cache files."
						$SHELL /usr/bin/bootmanager get_values 2>/dev/null 1>&2
						$SHELL /usr/bin/bootmanager html_display 2>/dev/null 1>&2
						$SHELL /usr/bin/bootmanager debug 2>&1 | $debugoutput
						rc=0
					fi
				fi
			else
				progress 3 97
				echo -e "$(get_localized $lang $rc)" 1>&2
			fi
			debug "modfs: switching system done, rc=$rc"
		elif [ "$switch" = "C" ]; then
			exit 1
		else
			echo -e "$(get_localized $lang 204)" 1>&2
		fi
	fi
fi
if [ $loopback_used -eq 1 ]; then
	# unmount and remove loopback partition, if it was used
	progress 1 142
	$bb umount -d "$unpack_directory"
	rc=$?
	if [ $rc -eq 0 ]; then
		progress 3 96
		progress 1 143
		$bb rm "$loopback_host" 2>/dev/null
		rc=$?
		lbdir="${loopback_host%/loopback}"
		[ x"$lbdir" != x"$loopback_host" ] && remove_directory "$lbdir"
		if [ $rc -eq 0 ]; then
			progress 3 96
		else
			progress 3 97
			echo -e "$(get_localized $lang 57)" 1>&2
			rc=57
		fi
	else
		echo -e "$(get_localized $lang 56)" 1>&2
		rc=56
		progress 3 97
	fi
	debug "modfs: unmounting loopback device done, rc=$rc"
	loopback_used=0
fi
#
# temporary directories to remove
#
if [ "$abort" = "Q" ]; then
	save_directory="${unpack_directory%/*}/modfs_rootdir"
	[ -d "$save_directory" ] && $bb rm -r "$save_directory"
	$bb mv "$unpack_directory/$squashfsdirname" "$save_directory" 2>/dev/null
	echo -e "$(get_localized $lang 223 "$save_directory")" 1>&2
fi
remove_directory "$unpack_directory"
remove_directory "$image_directory"
#
# all done ... cleanup will take place here
#
debug "modfs: reached normal exit point, rc=$rc"
exit $rc
